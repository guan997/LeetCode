# 贪心算法

一、基本概念

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

二、贪心算法的基本思路

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题
- 对每个子问题求解，得到子问题的局部最优解
- 把子问题的解局部最优解合成原来问题的一个解

三、适用场景

最大最小最优 

- 技巧：使用排序	使用堆

<img src='./images/1.png'>

## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

难度简单

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 10 ^ 4`
- `0 <= prices[i] <= 10 ^ 4`

#### 一次遍历

```js
let maxProfit = ((prices) => {
    let profit = 0; 
    for(let i = 0; i < prices.length; i++){
        if(prices[i] < prices[i + 1]){
            profit += prices[i + 1] - prices[i];
        }
    }
    return profit;
});
```

- 时间复杂度：O(n),只需遍历一次
- 空间复杂度：O(1),需要常量的空间

#### 贪心

 由于不限制交易次数，只要今天股价比昨天高，就交易。计算的过程并不是真正交易的过程

```js
let maxProfit = ((prices) => {
    let profit = 0; 
    for(let i = 0; i < prices.length; i++){
        if(prices[i] < prices[i + 1]){
            profit += Math.max(0, prices[i + 1] - prices[i]);
        }
    }
    return profit;
});
```

- 时间复杂度：O(n)，其中 n为数组的长度。我们只需要遍历一次数组即可。
- 空间复杂度：O(1)，只需要常数空间存放若干变量。

## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

难度简单

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

你可以认为 **s** 和 **t** 中仅包含英文小写字母。字符串 **t** 可能会很长（长度 ~= 500,000），而 **s** 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1:**
**s** = `"abc"`, **t** = `"ahbgdc"`

返回 `true`.

**示例 2:**
**s** = `"axc"`, **t** = `"ahbgdc"`

返回 `false`

#### 双指针+贪心算法

当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。

- 初始化两个指针i 和 j，分别指向 s 和t的初始位置。
- 每次贪心地匹配，匹配成功则 i和 j同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。
- 最终如果 i移动到 s 的末尾，就说明 s 是 t的子序列。

```js
let isSubsequence = ((s, t) => {
    let n = s.length, m = t.length;
    let i = 0, j = 0;
    while(i < n && j < m){
        if(s[i] == t[j]){
            i++;
        }
        j++;
    }
    return i == n;
});
```

- 时间复杂度：O(n+m)，其中 n 为 s 的长度，m 为 t 的长度。每次无论是匹配成功还是失败，都有至少一个指针发生右移，两指针能够位移的总距离为 n+m。
- 空间复杂度：O(1)

