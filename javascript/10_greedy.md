# 贪心算法

一、基本概念

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

二、贪心算法的基本思路

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题
- 对每个子问题求解，得到子问题的局部最优解
- 把子问题的解局部最优解合成原来问题的一个解

三、适用场景

最大最小最优 

- 技巧：使用排序	使用堆

<img src='./images/1.png'>

## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

难度简单

给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```

**示例 2:**

```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**提示：**

- `1 <= prices.length <= 3 * 10 ^ 4`
- `0 <= prices[i] <= 10 ^ 4`

#### 贪心+一次遍历

 由于不限制交易次数，只要今天股价比昨天高，就交易。计算的过程并不是真正交易的过程

```js
let maxProfit = ((prices) => {
    let profit = 0; 
    for(let i = 0; i < prices.length; i++){
        if(prices[i] < prices[i + 1]){
            profit += prices[i + 1] - prices[i];
        }
    }
    return profit;
});
```

- 时间复杂度：O(n),只需遍历一次
- 空间复杂度：O(1),需要常量的空间

```js
let maxProfit = ((prices) => {
    let profit = 0; 
    for(let i = 0; i < prices.length; i++){
        if(prices[i] < prices[i + 1]){
            profit += Math.max(0, prices[i + 1] - prices[i]);
        }
    }
    return profit;
});
```

- 时间复杂度：O(n)，其中 n为数组的长度。我们只需要遍历一次数组即可。
- 空间复杂度：O(1)，只需要常数空间存放若干变量。

## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

难度简单

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

你可以认为 **s** 和 **t** 中仅包含英文小写字母。字符串 **t** 可能会很长（长度 ~= 500,000），而 **s** 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**示例 1:**
**s** = `"abc"`, **t** = `"ahbgdc"`

返回 `true`.

**示例 2:**
**s** = `"axc"`, **t** = `"ahbgdc"`

返回 `false`

#### 双指针+贪心算法

当我们从前往后匹配，可以发现每次贪心地匹配靠前的字符是最优决策。

- 初始化两个指针i 和 j，分别指向 s 和t的初始位置。
- 每次贪心地匹配，匹配成功则 i和 j同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。
- 最终如果 i移动到 s 的末尾，就说明 s 是 t的子序列。

```js
let isSubsequence = ((s, t) => {
    let n = s.length, m = t.length;
    let i = 0, j = 0;
    while(i < n && j < m){
        if(s[i] == t[j]){
            i++;
        }
        j++;
    }
    return i == n;
});
```

- 时间复杂度：O(n+m)，其中 n 为 s 的长度，m 为 t 的长度。每次无论是匹配成功还是失败，都有至少一个指针发生右移，两指针能够位移的总距离为 n+m。
- 空间复杂度：O(1)

## [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

难度中等

在一条环路上有 *N* 个加油站，其中第 *i* 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 *i* 个加油站开往第 *i+1* 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

**说明:** 

- 如果题目有解，该答案即为唯一答案。
- 输入数组均为非空数组，且长度相同。
- 输入数组中的元素均为非负数。

**示例 1:**

```
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

**示例 2:**

```
输入: 
gas  = [2,3,4]
cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

#### 贪心算法+一次遍历

- 首先检查第 0个加油站，并试图判断能否环绕一周；如果不能，就从第一个无法到达的加油站开始继续检查。

```js
var canCompleteCircuit = function(gas, cost) {
    let i = 0;
    const n = gas.length;
    while(i < n){
        // 初始化所获得的汽油及消耗汽油均为0
        let gasTotal = 0, costTotal = 0;
        // 开始检查是否走完一圈
        let count = 0;
        while(count < n){
            // 因为道路是环形的，注意索引
            const j = (i + count) % n;
            // 统计可获得汽油量及消耗量总和，进行比较
            gasTotal += gas[j]
            costTotal += cost[j]
           // 获得汽油量小于消耗量时，表示汽油无法支撑到下一个加油站
            if(costTotal > gasTotal){
                break;
            }
            // 若油量支持驶向下个站，则继续检查
            count++;
        }
        // 如果 count 等于 n，表示走完所有的加油站，
        // 那么返回起始加油站编号 i
        if(count === n){
            return i;
        // 否则起始点重置为最后能到达的加油站的下一个加油站，
        // 其中 i + count 表示能到达的最后一个加油站
        }else{
            i = i + count + 1;
        }
    }
    // 若均无法走完一圈，返回 -1
    return -1;
};
```

- 时间复杂度：O(N)，其中 N为数组的长度。对数组进行了单次遍历。
- 空间复杂度：O(1)。

## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

难度困难

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

**示例:**

```
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

#### 贪心 正向查找可到达的最大位置

「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。

- 维护当前能够到达的最大下标位置maxPosition，记为边界。我们从左到右遍历数组求得下一步的最远位置，到达边界时，更新边界end并将跳跃次数steps增加 1。
- 在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。


```js
var jump = function(nums) {
    const length = nums.length;
    let end = 0, maxPosition = 0, steps = 0;
    for(let i = 0; i < length - 1; i++){
        // 求得下一步的最远位置。
        maxPosition = Math.max(maxPosition, i + nums[i]);
        if(i == end) {// 到达边界
            // 更新边界并将跳跃次数增加 1
            end = maxPosition;
            steps++;
        }
    }
    return steps;
};
```

- 时间复杂度：O(n)，其中 n 是数组长度。
- 空间复杂度：O(1)。

