# 程序员面试宝典

[面试题 01.01. 判定字符是否唯一](#面试题 01.01. 判定字符是否唯一)

## 面试题 01.01. 判定字符是否唯一

难度简单

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

**示例 1：**

```
输入: s = "leetcode"
输出: false 
```

**示例 2：**

```
输入: s = "abc"
输出: true
```

**限制：**

- `0 <= len(s) <= 100`
- 如果你不使用额外的数据结构，会很加分。

**双重循环**

```js
/**
 * @param {string} astr
 * @return {boolean}
 */
var isUnique = function(astr) {
    if(astr == null) return true;
    for(let i = 0; i < astr.length; i++){
        for(let j = i + 1; j < astr.length; j++){
            if(astr[i] === astr[j]){
                return false;
            }
        }
    }
    return true;
};
```

**set去重**

```js
/**
 * @param {string} astr
 * @return {boolean}
 */
var isUnique = function(astr) {
    return new Set(astr).size === astr.length;
};
```

**位运算**

举例 [3, 0, 3] 判断数组有重复元素

1. 利用左移运算 1 << 3 是 8 转换二进制 是 '1000'
2. 当遍历到0时，进行左移运算, 1 << 0 是 1 转换二进制 是 '0001'
3. 每次都与上一次结果进行或运算，8 | 1 是 9 转换二进制 是 '1001',
   这时可以看到我们用二进制中的位数是1来代表出现过。
4. 那如何快速判断是否出现过呢，可以采用与运算（位数都是1才会是1）的特性。
   如果之前没有出现过，那二进制中位数为1的位置对应不上，最后结果应该是0。
   例如：9 & (1 << 3) 会等于8，说明倒数第四位数，也就是 3重复了。
5. 我们将字母计算出左移的长度，即可像上述操作一样，检测是否只出现一次。

```js
/**
 * @param {string} astr
 * @return {boolean}
 */
var isUnique = function(astr) {
  let mark = 0;
  for (let char of astr) {
    // 需要左移的位数
    const c = char.charCodeAt() - 97;
    // mark 与 左移结果进行与运算，如果不是0，说明其中有一位都是1，说明重复
    if ((mark & (1 << c)) !== 0) {
      return false;
    }
    // 不重复，mark 与 左移结果 进行或运算，相当于保存该值
    mark = mark | (1 << c);
  }
  return true;
};
```

## 面试题 01.02. 判定是否互为字符重排

难度简单

给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**

```
输入: s1 = "abc", s2 = "bca"
输出: true 
```

**示例 2：**

```
输入: s1 = "abc", s2 = "bad"
输出: false
```

**说明：**

- `0 <= len(s1) <= 100`
- `0 <= len(s2) <= 100`

**判断长度**

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var CheckPermutation = function(s1, s2) {
    //长度不对等,肯定不行的
    if(s1.length!=s2.length){
        return false;
    }
    s2 = s2.split('');
    //直接循环
    for(let s of s1){
        if(s2.indexOf(s)==-1){
            return false;
        }else{
            s2.splice(s2.indexOf(s),1);
        }
    }
    return true;
};
```

**把字符串转换为数组，用sort排序后再转换为字符串，进行比较**

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var CheckPermutation = function(s1, s2) {
    return s1.split('').sort().toString()===s2.split('').sort().toString();
};
```

## 面试题 02.02. 返回倒数第 k 个节点

难度简单

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：**本题相对原题稍作改动

**示例：**

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

**说明：**

给定的 *k* 保证是有效的。

**双指针**

定义两个指针，当快指针走的时候，计数n++, 直到快慢指针之间的偏移量达到了k，慢指针开始移动。当快指针遍历完的同时，慢指针刚好就是倒数k个值。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {number}
 */
var kthToLast = function (head, k) {
    let fast = head
    let low = head
    let n = 0
    while (fast) {
        fast = fast.next
        if (n >= k) {// 快慢指针之间的偏移量达到了k
            low = low.next//慢指针开始移动
        }
        n++
    }
    return low.val
};
```

- 时间复杂度 O(n)
- 空间复杂度 O(1)

**栈**

把原链表的结点全部压栈，然后再把栈arr.length - k个节点出栈

```js
var kthToLast = function(head, k) {
    //利用栈的特性
    const arr = []
    while(head) {// 遍历链表，入栈
        arr.push(head.val)
        head = head.next;
    }
    return arr[arr.length - k]
};
```

