# 网易

# 牛牛找工作

题目描述

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。

输入描述:

```
每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。
```

输出描述:

```
对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。
```

示例1

输入

```
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000
```

输出

```
100 
1000 
1001
```

## 排序+map

工作可以多次选择，只需要考虑工作，建立一个map,存储工作能力-报酬映射关系，把小伙伴的能力和报酬也存储进去，报酬初始化为0；从小到大依次更新最大报酬，有动态规划和马尔可夫过程的思想存在，当前最大报酬取决于当前能力与前一个能力对应的最大报酬。

```js
//https://www.nowcoder.com/practice/46e837a4ea9144f5ad2021658cb54c4d?tpId=98&tqId=32824&tPage=1&rp=1&ru=/ta/2019test&qru=/ta/2019test/question-ranking
let objCount,memberCount,Di=[],Pi={};//工作的数量objCount 小伙伴的数量memberCount 工作的难度Di 报酬Pi 
let list = readline().split(' ');// readline()按行读取之后split()指定在空格处把一个字符串分割成字符串数组。
objCount = parseInt(list[0]);//工作的数量
memberCount = parseInt(list[1]);//小伙伴的数量
let i = 0;
while(i<objCount) {//遍历获取工作的难度Di 报酬Pi 
    list = readline().split(' ');
    if (list.length >= 2) {
        //建立一个map,存储工作的难度Di 报酬Pi 的关系 10 => 1000
        Di[i] = parseInt(list[0]);
        Pi[Di[i]] = parseInt(list[1]);
        i++;
    }
}
//对Di排序，将数组升序排列
Di.sort(function(a,b){
    return a-b;
})
//遍历工作的难度
for (let i = 0, len = Di.length; i < len; i++) {
    //对同等工作难度Di下的报酬Pi排序
        Pi[Di[i]] = i === 0 || Pi[Di[i]] >= Pi[Di[i - 1]] ? Pi[Di[i]] : Pi[Di[i - 1]];
}
//获取小伙伴的能力值
while(true) {
    list = readline().split(' ');
    if(list.length===memberCount) {
        break
    }
}
//遍历小伙伴的能力值，调用findMax()返回最高报酬  
for(let i=0,len = list.length;i<len;i++) {
    console.log(findMax(parseInt(list[i]),Di,Pi))
}
//二分查找最高报酬    
function findMax(item,Di,Pi) {
    let start = 0;
    let end = Di.length-1;
    while(start<=end) {
        let mid = parseInt((start+end)/2);
        if(Di[mid]==item) {
            return Pi[Di[mid]];
        } else if(Di[mid]>item){
            end = mid-1;
        } else {
            start = mid+1;
        }     
    }
    if(start===0) {
        return 0
    } else {
        return Pi[Di[start-1]];
    }  
}
```

# 被3整除

题目描述

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

输入描述:

```
输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。
```

输出描述:

```
输出一个整数, 表示区间内能被3整除的数字个数。
```

输入

```
2 5
```

输出

```
3
```

说明

```
12, 123, 1234, 12345...
其中12, 123, 12345能被3整除。
```

## 数学

解题思路：

- 该题结果应该为A[i] % 3,若结果为A[i]%3 = (1+2+3+...+i)%3;
- 自然数序列1,2,3,4,5...i取模3的结果分别是1,2,0,1,2,0,...,i % 3
- 可以等性质A[i]%3 = (1+2+0+1+2+0...+i%3)%3
- 所以可得当i%3 = 0时，必定可以被整除
- 当余2时，因为前面余了一个1，所以（1+2）%3也可以被整除，只有余1时不能被整除。

```js
var readline = require('readline');
const r1 = readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
r1.on('line',function(line){
    let inputData = line.split(' ');
    let start = parseInt(inputData[0]),
        end = parseInt(inputData[1]);
    let result = 0;
    for(; start <= end; start++){
          if(start % 3 != 1){
                 result ++;
          }
    }
    console.log(result);
});
// 测试1
// 2 5
// 3
// 测试2
// 10 110
// 67
```

# 解题模板

- node.js

```js
var readline = require('readline');

rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
//单行输入
rl.on('line', function(data) {
    // 获取输入
    var inputs = data.trim().split(' ');

    // 处理
    var result = deal(inputs);

    // 输出结果
    console.log(result);
});


function deal(inputs) {
    var result = '';

    // dosomething

    return result;
}
```

## 例题

输入N个（N<=10000）数字，求出这N个数字中的最大值和最小值。每个数字的绝对值不大于1000000。

```js
var readline = require('readline');
var rl = readline.createInterface({
    input:process.stdin,
    output:process.stdout,
});
var num = 0;
 
rl.on('line',function(input){
    if(num==0){
        num = input.trim();
    }
    else{
        var iptArr = input.split(' ');
        if(iptArr.length==num){
            var maxNum = Math.max.apply(null,iptArr);
            var minNum = Math.min.apply(null,iptArr);
            var result = maxNum + ' ' + minNum;
            console.log(result);
            return result;
        }
    }
})
//输入
5                    //输入N个数的数量
12 18 5 20 10        //N个数
20 5                //返回结果
```

# 