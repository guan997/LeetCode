# 网易

## 牛牛找工作

题目描述

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。

输入描述:

```
每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。
```

输出描述:

```
对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。
```

示例1

输入

```
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000
```

输出

```
100 
1000 
1001
```

### 排序+map

工作可以多次选择，只需要考虑工作，建立一个map,存储工作能力-报酬映射关系，把小伙伴的能力和报酬也存储进去，报酬初始化为0；从小到大依次更新最大报酬，有动态规划和马尔可夫过程的思想存在，当前最大报酬取决于当前能力与前一个能力对应的最大报酬。

```js
//https://www.nowcoder.com/practice/46e837a4ea9144f5ad2021658cb54c4d?tpId=98&tqId=32824&tPage=1&rp=1&ru=/ta/2019test&qru=/ta/2019test/question-ranking
let objCount,memberCount,Di=[],Pi={};//工作的数量objCount 小伙伴的数量memberCount 工作的难度Di 报酬Pi 
let list = readline().split(' ');// readline()按行读取之后split()指定在空格处把一个字符串分割成字符串数组。
objCount = parseInt(list[0]);//工作的数量
memberCount = parseInt(list[1]);//小伙伴的数量
let i = 0;
while(i<objCount) {//遍历获取工作的难度Di 报酬Pi 
    list = readline().split(' ');
    if (list.length >= 2) {
        //建立一个map,存储工作的难度Di 报酬Pi 的关系 10 => 1000
        Di[i] = parseInt(list[0]);
        Pi[Di[i]] = parseInt(list[1]);
        i++;
    }
}
//对Di排序，将数组升序排列
Di.sort(function(a,b){
    return a-b;
})
//遍历工作的难度
for (let i = 0, len = Di.length; i < len; i++) {
    //对同等工作难度Di下的报酬Pi排序
        Pi[Di[i]] = i === 0 || Pi[Di[i]] >= Pi[Di[i - 1]] ? Pi[Di[i]] : Pi[Di[i - 1]];
}
//获取小伙伴的能力值
while(true) {
    list = readline().split(' ');
    if(list.length===memberCount) {
        break
    }
}
//遍历小伙伴的能力值，调用findMax()返回最高报酬  
for(let i=0,len = list.length;i<len;i++) {
    console.log(findMax(parseInt(list[i]),Di,Pi))
}
//二分查找最高报酬    
function findMax(item,Di,Pi) {
    let start = 0;
    let end = Di.length-1;
    while(start<=end) {
        let mid = parseInt((start+end)/2);
        if(Di[mid]==item) {
            return Pi[Di[mid]];
        } else if(Di[mid]>item){
            end = mid-1;
        } else {
            start = mid+1;
        }     
    }
    if(start===0) {
        return 0
    } else {
        return Pi[Di[start-1]];
    }  
}
```

### 被3整除

题目描述

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

输入描述:

```
输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。
```

输出描述:

```
输出一个整数, 表示区间内能被3整除的数字个数。
```

输入

```
2 5
```

输出

```
3
```

说明

```
12, 123, 1234, 12345...
其中12, 123, 12345能被3整除。
```

### 数学

解题思路：

- 该题结果应该为A[i] % 3,若结果为A[i]%3 = (1+2+3+...+i)%3;
- 自然数序列1,2,3,4,5...i取模3的结果分别是1,2,0,1,2,0,...,i % 3
- 可以等性质A[i]%3 = (1+2+0+1+2+0...+i%3)%3
- 所以可得当i%3 = 0时，必定可以被整除
- 当余2时，因为前面余了一个1，所以（1+2）%3也可以被整除，只有余1时不能被整除。

```js
var readline = require('readline');
const r1 = readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
r1.on('line',function(line){
    let inputData = line.split(' ');
    let start = parseInt(inputData[0]),
        end = parseInt(inputData[1]);
    let result = 0;
    for(; start <= end; start++){
          if(start % 3 != 1){
                 result ++;
          }
    }
    console.log(result);
});
// 测试1
// 2 5
// 3
// 测试2
// 10 110
// 67
```

# 快手

## 合并k个已排序的链表

题目描述

合并k个已排序的链表并将其作为一个已排序的链表返回。分析并描述其复杂度。 

`同leetcode23. 合并K个升序链表`

示例1

输入

```
[{1,2,3},{4,5,6,7}]
```

返回值

```
{1,2,3,4,5,6,7}
```

### 链表

```js
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
  let res = [];
  // 把所有节点放在res中
  for (let i = 0; i < lists.length; i++) {
    let list = lists[i];
    while(list) {
      res.push(list);
      list = list.next;
    }
  }
  // res根据节点的值排序一下
  res.sort((a, b) => a.val - b.val);
  // 重新设置next
  for (let i = 0; i < res.length; i++) {
    res[i].next = res[i + 1] || null;
  }
  // 返回节点头
  return res[0];
}
module.exports = {
    mergeKLists : mergeKLists
};
```

### 分治合并

```js
function mergeKLists( lists ) {
  /* 分而治之 */
  if (lists.length <= 1) return lists[0] || null;
  const newLists = [];
  for (let i = 0; i < lists.length; i += 2) {
    newLists.push(merge(lists[i], lists[i + 1] || null));
  }
  return mergeKLists(newLists);
};

const merge = (list_1, list_2) => {
  const head = new ListNode(0);
  let tail  = head;

  while (list_1 && list_2) {
    if (list_1.val < list_2.val) {
      tail.next = list_1;
      list_1 = list_1.next;
    } else {
      tail.next = list_2;
      list_2 = list_2.next;
    }
    tail  = tail.next;
  }

  tail.next = list_1 ? list_1 : list_2;
  return head.next; 
};
```

# 搜狗

# 问答题

请简述XMLHttpRequest、JSONP的适用场景，并针对两种请求形式简述如何检测请求错误

答：

1. XMLHttpRequest用于浏览器端与服务器端异步请求数据从面实现对页面的无刷新修改，支持GET/POST请求，一般用于非跨域的场景。如果需要使用XMLHttpRequest跨域请求数据，需要通过CORS头支持。 JSONP用于跨域请求数据的场景，只支持GET请求。
2. .XMLHttpRequest异常判断一般通过该对象的readystate和http状态码status来判断，JSONP的异常判断一般是onerror事件和超时timer来判断。

请简述浏览器渲染页面的过程,并给出下方script代码中对哪些CSS属性的"修改"会触发重绘（repaint）和重排（reflow）？

<style>.sg-container {padding: 10px;margin-bottom: 10px;width: 100px; height: 100px;}</style>
<div class="sg-container">
  <p style="line-height:20px">2019搜狗校园招聘</p>
<script>
  document.querySelector('p').style.cssText +='height:10px; line-height:24px;font-size:20px;visibility:hidden;background-color:#00f;border:1px solid #f00';
</script>
</div>

答：

浏览器渲染过程因不同内核可能会有差异，现以webkit为例描述浏览器渲染原理，浏览器渲染过程主要分为三个阶段，先详述如下：
第一阶段：

1. 用户输入URL时，webkit依赖网络模块加载网页或资源数据
2. 网页被交给HTML解释器转变成一系列的词语
3. 解释器根据词语构建节点并形成DOM树
4.  如果节点是CSS、图片、视频等资源，会调用资源加载器加载他们，因该类资源加载是异步的，不会阻塞当前DOM树的继续创建
5. 如果节点是javascript，停止当前DOM树的创建，直到javascript资源加载完成并被javascript引擎执行后才继续进行DOM的创建

第二阶段：

1. CSS解释器解析CSS文件成内部表示结构，并在DOM树上附加样式信息形成RenderObject树
2. RenderObject节点在创建的同时，webkit会根据网页的层次结构创建RenderLayer树，同时创建一个虚拟的绘图上下文

第三阶段：

1. 根据生成的绘图上下文和2D或3D图形库生成最终的图像
   对于包含动画和用户交互的动态网页，浏览器的渲染过程会重复的执行，可能会触发不同程度的重排和重绘。

重排属性：height、line-height、font-size、border
重绘属性：height、line-height、font-size 、border、background-color、visibility

## 检测页面标签

完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下

```
<``html``>`` ``<``head``></``head``>`` ``<``body``>``  ``<``div``></``div``>``  ``<``p``></``p``>`` ``</``body``>``</``html``>
```

注意：

-  1、标签名称使用小写
- 2、请使用ES5语法
- 3、答题时不要使用第三方插件

【解析】

```js
var arrNew = [];
(function getTags() {
    var list1 = document.getElementsByTagName('*');
    for(const key in list1){
        if(list1.hasOwnProperty(key)){
            const element = list1[key];
            arrNew.push(element.tagName);
        }
    }
    arrNew = arrNew.join(',').toLowerCase().split(',');
    console.log(arrNew);
})()
```

## 服务器数据分发

时间限制：C/C++ 5秒，其他语言10秒

空间限制：C/C++ 256M，其他语言512M

【题干描述】：我们共有n台服务器，每台服务器可以和若干个子服务器传输数据，n台服务器组成一个树状结构。现在要将一份数据从root节点开始分发给所有服务器。一次数据传输需要一个小时时间，一个节点可以同时对k个儿子节点进行并行传输，不同节点可以并行分发。问，全部分发完成，最短需要多少小时？
【示例】：当共有5台服务器，其树状结构为    0   /   \  1   2 /  \ 3  4假设每一台服务器同时可以对1个儿子节点（k=1）并行传输，最优的数据传输过程示例如下：  第一个小时，0 -> 1；  第二个小时，1->3 & 0->2；  第三个小时，1 -> 4;所以当k=1时，全部分发完成最短需要3个小时。假设每一台服务器同时可以对2个儿子节点（k=2）并行传输，最优的数据传输过程示例如下：  第一个小时，0 -> 1 & 0 -> 2;  第二个小时，1 -> 3 & 1 -> 4;所以当k=2时，全部分发完成最短需要2个小时。

**输入描述:**

```
首行输入包含两个参数，分别表示每台服务器允许k个子节点并行传输，以及剩余输入行数。
其他行用于服务器树状结构描述，每一行表示一个父节点以及父节点对应的所有子节点。每一行都通过空格符分割不同数字，第一位数字为父节点及其所有子节点个数，第二位数字为父节点编号，其他数字为对应的子节点编号。
```

**输出描述:**

```
输出全部服务器分发完成，需要的最短时间。
```

**输入例子1:**

```
1 2
3 0 1 2
2 1 3
```

**输出例子1:**

```
2
```

```js
var readline = require('readline')
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
})
var inputs = [];
rl.on('line', function(input) {
    inputs.push(input.trim());
    if(inputs[0].split(' ')[1] == inputs.length-1)
    {
        //每找到一个父节点，就让并可发次数加上本身一次
        //计算每行除了父节点的总个数，也就是求除了第一行的inputs的首个元素-1的总和-1
        //然后用总数减去每次找到后的并发数，共计减几次即为几小时
        var pNodeSum = inputs.length-2;
        var nodeSum = 0;
        var hour = inputs[0].split(' ')[0]-0;//-0是快速转化为数字
        var count = 0;
        for(let i = 1;i<inputs.length-1;i++)
            nodeSum+=inputs[i].split(' ')[0]-1;
        for(let j = pNodeSum;j>0;j--)
        {
            nodeSum -= hour;
            hour += hour;
            count++;
        }
        if(nodeSum>0)
            count+=Math.ceil(nodeSum/hour);
        console.log(count);
    }
})
```

# 同盾科技

## 大数相加

题目描述

以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。

（字符串长度不大于100000，保证字符串仅由'0'~'9'这10种字符组成）

示例1

输入

```
"1","99"
```

返回值

```
"100"
```

说明

```
1+99=100 
```

### **前补0**

（1）通过**前补0**的方式，先对齐两个字符串数字的长度, 之后，两两对应位置，进行相加，判断和是否大于10：

（2）大于10则前一位进位加1，本位留个位数字。

（3）小于10则直接相加，留下。

（4）最终检查一下进位是否为1（为1，代表进位，拼接字符串）

最后，返回答案字符串

```js
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength, 0);//"0009007199254740991"
   b = b.padStart(maxLength, 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i = maxLength - 1; i>=0; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t / 10);
      sum = t % 10 + sum;
   }
   if(f == 1){
      sum = "1" + sum;
   }
   return sum;
}
//运行：

//add(a ,b); //结果为：1243575099254740990
```

### 转换成数组

转换成数组 个位对齐 注意进位

- 将传进来的数字/数字字符串调用toString方法转换成字符串，并进行切割，转成数组
- 判断两个数组的长度，进行值的互换，将splitNum1设置为最长的值，方便后续计算
- carry: 进位值； currentNum: 相加之后，除以10的余数； sum: 相加的值
- 相加，判断是否有进位

```js
function add(strNum1, strNum2) {
  // 将传进来的数字/数字字符串调用toString方法转换成字符串，并进行切割，转成数组
  let splitNum1 = strNum1.toString().split(''),
    splitNum2 = strNum2.toString().split('')

  // 判断两个数组的长度，进行值的互换，将splitNum1设置为最长的值，方便后续计算
  if (splitNum1.length < splitNum2.length) {
    let temp = splitNum1
    splitNum1 = splitNum2
    splitNum2 = temp
  }

  // carry: 进位值； currentNum: 相加之后，除以10的余数； sum: 相加的值
  let len1 = splitNum1.length,
    len2 = splitNum2.length,
    carry = 0,
    currentNum = 0,
    sum = 0

  // len1递减到1之后，循环体中的len1 - 1 = 0 即可拿到下标为零的数组元素，
  // 所以这里条件是 大于 0，下面len2 > 0 同理
  while (len1 > 0) {
    if (len2 > 0) {
      sum = parseInt(splitNum1[len1 - 1]) + parseInt(splitNum2[len2 - 1]) + carry
    } else {
      sum = parseInt(splitNum1[len1 - 1]) + carry
    }
    carry = Math.floor(sum / 10) // 进位数值
    currentNum = sum % 10 // 取余数，作为当前位置的数值
    splitNum1[len1 - 1] = currentNum // 设置当前值

    // 相加之后，数值长度都递减
    len1--
    len2--
  }
  // 判断是否还有进位
  if (carry) {
    splitNum1.unshift(1)
  }
  return splitNum1.join('')
}
let str1 = 123456789;
let str2 = 11;
let result = add(str1, str2)

console.log('result :', result) // result : 11546
```

# 奇安信

## 采购员

**题目描述：**

 1.2020年春节之际，新冠肺炎爆发，国内医疗资源大量紧缺

 2.小明作为一位采购员，被派到国外采购紧缺物资

 3.由于国内需要的物资种类很多，不同品牌种类的物资在疫情中的 使用价值 也不同

 4.在了解商品情况后，小明开始为采购哪些物资才最合适而烦恼。

 5.假如给定了采购预算 T , 每种物资的价格Pn和使用价值 Wn

 6.每种物资的可采购数量不限，你能帮他快速决定出应该采购的物资吗？

 7.要求采购物资的总价格不能超过采购预算

 8.在这个前提下给出的采购列表要使得这批物资的使用价值最大。

 **输入描述:**
 每个测试输入包含一个测试用例
 第一行是总预算(不大于200000)
 第二行是物资种类总数 n (不大于20)
 后面有n行数据， 每一行代表一种物资的价格和使用价值，被空格分成两列， 每列数据值不大于15000

 例如 第3行数据中 第一列是物资1的价格P1, 第二列是物资2的使用价值 W1
 第4行数据中 第一列是物资2的价格 P2, 第二列是物资2的使用价值 W2。
 以此类推，第 n+2 行中第一列是物资 n 的价格 Pn ，第二列是 物资 n 的价格 Wn。

 **输出描述:**
 输出采购物资能达到的最高使用价值，格式是单独的一行 数值

```js
 示例1：
 输入
 100
 5
 77 92
 22 22
 29 36
 50 46
 99 90
 输出
 114
```

 说明
 100预算、5种商品情况下，购买 1个商品一 和 1个商品二 可以达到最大使用价值114

 ```js
示例2：
 输入
 200
 8
 79 83
 58 81
 86 54
 110 1500
 62 52
 45 48
 68 62
 30 22

 输出
 253
 ```

 说明
 200预算、8种商品情况下，购买 1个商品二 、 1个商品四 和 一个商品八 可以达到最大使用价值253

 **备注:**
 **注意：每种物资的可采购数量没有限制**

## 亲7数的个数

**题目描述：**

1.如果一个正整数可以被7整除，我们称之为亲7数

2.对于给出的一组个位数字，请找出使用所有的数字排列出的数中的亲7数的个数。

3.其中给出的个位数字数组中每一个都是不相关的，即使有重复的数字

4.如{1，1，2}排列出的数为{**112，121，112，121，211，211**}， 亲7数为{112，112}共2个。

输入：个位数字数组，数组有m个元素

输出：亲7数个数

示例1:
输入
[1,1,2]

输出
2

### 暴力 + 回溯

```js
def permutation(digit):
    s= []
    for i in digit:
        s.append(str(i))
        c, res = list(s), []
    def dfs(x):
        if x == len(c) - 1:
            res.append(''.join(c)) # 添加排列方案
            return 
        dic = []
        for i in range(x, len(c)):
            #if c[i] in dic: continue # 重复，因此剪枝
            dic.append(c[i])
            c[i], c[x] = c[x], c[i] # 交换，将 c[i] 固定在第 x 位
            dfs(x + 1) # 开启固定第 x + 1 位字符
            c[i], c[x] = c[x], c[i] # 恢复交换
    dfs(0)
    result = []
    for i in res:
        if int(i) % 7 == 0:
            result.append((int(i)))

    return len(result)
permutation([1,1,2])
>> 2
```

### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

**搜索回溯**

```js
const permuteUnique = (nums) => {
  const res = [];
  const len = nums.length;
  const used = new Array(len);
  nums.sort((a, b) => a - b); // 升序排序

  const helper = (path) => {
    if (path.length == len) { // 个数选够了
      res.push(path.slice()); // path的拷贝 加入解集
      return;                 // 结束当前递归 结束当前分支
    }

    for (let i = 0; i < len; i++) { // 枚举出所有的选择
      if (nums[i - 1] == nums[i] && i - 1 >= 0 && !used[i - 1]) { // 避免产生重复的排列
        continue;
      }
      if (used[i]) {      // 这个数使用过了，跳过。
        continue;
      }
      path.push(nums[i]); // make a choice
      used[i] = true;     // 记录路径上做过的选择
      helper(path);       // explore，基于它继续选，递归
      path.pop();         // undo the choice
      used[i] = false;    // 也要撤销一下对它的记录
    }
  };

  helper([]);
  return res;
};
```

- 时间复杂度：*O*(*n*×*n*!)
- 空间复杂度：O(n)。我们需要 O(n)的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n + n)=O(2n)=O(n)

# 解题模板

- node.js

```js
var readline = require('readline');

rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
//单行输入
rl.on('line', function(data) {
    // 获取输入
    var inputs = data.trim().split(' ');

    // 处理
    var result = deal(inputs);

    // 输出结果
    console.log(result);
});


function deal(inputs) {
    var result = '';

    // dosomething

    return result;
}
```

## 例题

输入N个（N<=10000）数字，求出这N个数字中的最大值和最小值。每个数字的绝对值不大于1000000。

```js
var readline = require('readline');
var rl = readline.createInterface({
    input:process.stdin,
    output:process.stdout,
});
var num = 0;
 
rl.on('line',function(input){
    if(num==0){
        num = input.trim();
    }
    else{
        var iptArr = input.split(' ');
        if(iptArr.length==num){
            var maxNum = Math.max.apply(null,iptArr);
            var minNum = Math.min.apply(null,iptArr);
            var result = maxNum + ' ' + minNum;
            console.log(result);
            return result;
        }
    }
})
//输入
5                    //输入N个数的数量
12 18 5 20 10        //N个数
20 5                //返回结果
```

# 