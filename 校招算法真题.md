# 网易

## 牛牛找工作

题目描述

为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。

输入描述:

```
每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。
```

输出描述:

```
对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。
```

示例1

输入

```
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000
```

输出

```
100 
1000 
1001
```

### 排序+map

工作可以多次选择，只需要考虑工作，建立一个map,存储工作能力-报酬映射关系，把小伙伴的能力和报酬也存储进去，报酬初始化为0；从小到大依次更新最大报酬，有动态规划和马尔可夫过程的思想存在，当前最大报酬取决于当前能力与前一个能力对应的最大报酬。

```js
//https://www.nowcoder.com/practice/46e837a4ea9144f5ad2021658cb54c4d?tpId=98&tqId=32824&tPage=1&rp=1&ru=/ta/2019test&qru=/ta/2019test/question-ranking
let objCount,memberCount,Di=[],Pi={};//工作的数量objCount 小伙伴的数量memberCount 工作的难度Di 报酬Pi 
let list = readline().split(' ');// readline()按行读取之后split()指定在空格处把一个字符串分割成字符串数组。
objCount = parseInt(list[0]);//工作的数量
memberCount = parseInt(list[1]);//小伙伴的数量
let i = 0;
while(i<objCount) {//遍历获取工作的难度Di 报酬Pi 
    list = readline().split(' ');
    if (list.length >= 2) {
        //建立一个map,存储工作的难度Di 报酬Pi 的关系 10 => 1000
        Di[i] = parseInt(list[0]);
        Pi[Di[i]] = parseInt(list[1]);
        i++;
    }
}
//对Di排序，将数组升序排列
Di.sort(function(a,b){
    return a-b;
})
//遍历工作的难度
for (let i = 0, len = Di.length; i < len; i++) {
    //对同等工作难度Di下的报酬Pi排序
        Pi[Di[i]] = i === 0 || Pi[Di[i]] >= Pi[Di[i - 1]] ? Pi[Di[i]] : Pi[Di[i - 1]];
}
//获取小伙伴的能力值
while(true) {
    list = readline().split(' ');
    if(list.length===memberCount) {
        break
    }
}
//遍历小伙伴的能力值，调用findMax()返回最高报酬  
for(let i=0,len = list.length;i<len;i++) {
    console.log(findMax(parseInt(list[i]),Di,Pi))
}
//二分查找最高报酬    
function findMax(item,Di,Pi) {
    let start = 0;
    let end = Di.length-1;
    while(start<=end) {
        let mid = parseInt((start+end)/2);
        if(Di[mid]==item) {
            return Pi[Di[mid]];
        } else if(Di[mid]>item){
            end = mid-1;
        } else {
            start = mid+1;
        }     
    }
    if(start===0) {
        return 0
    } else {
        return Pi[Di[start-1]];
    }  
}
```

### 被3整除

题目描述

小Q得到一个神奇的数列: 1, 12, 123,...12345678910,1234567891011...。

并且小Q对于能否被3整除这个性质很感兴趣。

小Q现在希望你能帮他计算一下从数列的第l个到第r个(包含端点)有多少个数可以被3整除。

输入描述:

```
输入包括两个整数l和r(1 <= l <= r <= 1e9), 表示要求解的区间两端。
```

输出描述:

```
输出一个整数, 表示区间内能被3整除的数字个数。
```

输入

```
2 5
```

输出

```
3
```

说明

```
12, 123, 1234, 12345...
其中12, 123, 12345能被3整除。
```

### 数学

解题思路：

- 该题结果应该为A[i] % 3,若结果为A[i]%3 = (1+2+3+...+i)%3;
- 自然数序列1,2,3,4,5...i取模3的结果分别是1,2,0,1,2,0,...,i % 3
- 可以等性质A[i]%3 = (1+2+0+1+2+0...+i%3)%3
- 所以可得当i%3 = 0时，必定可以被整除
- 当余2时，因为前面余了一个1，所以（1+2）%3也可以被整除，只有余1时不能被整除。

```js
var readline = require('readline');
const r1 = readline.createInterface({
    input:process.stdin,
    output:process.stdout
});
r1.on('line',function(line){
    let inputData = line.split(' ');
    let start = parseInt(inputData[0]),
        end = parseInt(inputData[1]);
    let result = 0;
    for(; start <= end; start++){
          if(start % 3 != 1){
                 result ++;
          }
    }
    console.log(result);
});
// 测试1
// 2 5
// 3
// 测试2
// 10 110
// 67
```

# 快手

## 合并k个已排序的链表

题目描述

合并k个已排序的链表并将其作为一个已排序的链表返回。分析并描述其复杂度。 

`同leetcode23. 合并K个升序链表`

示例1

输入

```
[{1,2,3},{4,5,6,7}]
```

返回值

```
{1,2,3,4,5,6,7}
```

### 链表

```js
/**
 * 
 * @param lists ListNode类一维数组 
 * @return ListNode类
 */
function mergeKLists( lists ) {
  let res = [];
  // 把所有节点放在res中
  for (let i = 0; i < lists.length; i++) {
    let list = lists[i];
    while(list) {
      res.push(list);
      list = list.next;
    }
  }
  // res根据节点的值排序一下
  res.sort((a, b) => a.val - b.val);
  // 重新设置next
  for (let i = 0; i < res.length; i++) {
    res[i].next = res[i + 1] || null;
  }
  // 返回节点头
  return res[0];
}
module.exports = {
    mergeKLists : mergeKLists
};
```

### 分治合并

```js
function mergeKLists( lists ) {
  /* 分而治之 */
  if (lists.length <= 1) return lists[0] || null;
  const newLists = [];
  for (let i = 0; i < lists.length; i += 2) {
    newLists.push(merge(lists[i], lists[i + 1] || null));
  }
  return mergeKLists(newLists);
};

const merge = (list_1, list_2) => {
  const head = new ListNode(0);
  let tail  = head;

  while (list_1 && list_2) {
    if (list_1.val < list_2.val) {
      tail.next = list_1;
      list_1 = list_1.next;
    } else {
      tail.next = list_2;
      list_2 = list_2.next;
    }
    tail  = tail.next;
  }

  tail.next = list_1 ? list_1 : list_2;
  return head.next; 
};
```

## 判断一个链表是否为回文结构

**题目描述**

给定一个链表，请判断该链表是否为回文结构。

示例1

输入

```
[1,2,2,1]
```

返回值

```
true
```

### 快慢指针

快慢指针定位到中间节点，然后把后半部分链表反转，然后顺序比较

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head
 * @return bool布尔型
 */
function isPail( head ) {
    // write code here
  if(!head || !head.next) return true
    let arr = []
    let slow = head,fast = head
    while(fast && fast.next) {
        arr.push(slow.val)
        fast = fast.next.next
        slow = slow.next
    }
    if(fast) {
        slow = slow.next
    }
    while(slow) {
        if(slow.val != arr.pop()) return false
        slow = slow.next
    }
    return true
}
module.exports = {
    isPail : isPail
};
```

## 求平方根

**题目描述**

实现函数 int sqrt(int x).

计算并返回x的平方根（向下取整）

示例1

输入

```
2
```

返回值

```
1
```

### 二分法

- 1.初始范围为1，x
- 2.当`mid*mid <= x && (mid+1)*(mid+1) > x`时，返回结果
- 3.当`mid*mid < x`时，到右半部分继续寻找
- 4.当`mid*mid > x`时，到左半部分继续寻找
- ps：避免溢出使用逆向运算

```js
/**
  * 
  * @param x int整型 
  * @return int整型
  */
function sqrt( x ) {
    // write code here
    // 考虑溢出
    if(x <= 0) return 0;
    let left = 1, right = x;
    while(left < right){
        let mid = Math.floor((left + right) / 2);
        if(mid * mid <= x && (mid + 1) * (mid + 1) > x) return mid;
        if(mid * mid > x){
            right = mid;
        }else{
            left = mid;
        }
    }
    return left;
}
module.exports = {
    sqrt : sqrt
};
```

## 数字在升序数组中出现的次数

**题目描述**

统计一个数字在升序数组中出现的次数。

示例1

输入

```
[1,2,3,3,3,3,4,5],3
```

返回值

```
4
```

**暴力**

```js
function GetNumberOfK(data, k)
{
    // write code here
    let count = 0;
    for(let i = 0; i < data.length; i++) {
        if(data[i] === k) {
            count++;
        }
    }
    return count;
}
module.exports = {
    GetNumberOfK : GetNumberOfK
};
```

### 二分查找

解题思路：

因为有序，所以目标值`target`如果有多个，肯定是连在一起。又已知我们可以在有序数组中查找任意一个值，因此我们可以先查找目标范围的下界和上界。
下界定义为：如果存在目标值，则指向第一个目标值，否则，如果不存在， 则指向大于目标值的第一个值。
上界定义为：不管目标值存在与否，都指向大于目标值的第一个值。

```js
function GetNumberOfK(data, k)
{
    // write code here
    let start = 0
    let end = data.length - 1
    while (start <= end) {
        const mid = Math.floor(start + (end - start) / 2)
        if (data[mid] <= k) {
            start = mid + 1
        } else {
            end = mid - 1
        }
    }
    let right = start
    start = 0
    end = data.length - 1
     while (start <= end) {
        const mid = Math.floor(start + (end - start) / 2)
        if (data[mid] < k) {
            start = mid + 1
        } else {
            end = mid - 1
        }
    }
    let left = end
    return right - left -1
}
module.exports = {
    GetNumberOfK : GetNumberOfK
};
```

## 岛屿数量

**题目描述**

给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。

岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。

示例1

输入

```
[[1,1,0,0,0],[0,1,0,1,1],[0,0,0,1,1],[0,0,0,0,0],[0,0,1,1,1]]
```

返回值

```
3
```

备注:

```
01矩阵范围<=200*200
```

**思路：**

1. 遍历整块大陆，横着竖着遍历都可以。
2. 第一次碰到陆地的时候，就知道这是块岛屿了，所以将这块陆地放入探险队列，岛屿数量加一。
3. 然后我们将这块岛屿的陆地探索完。每一次将这块陆地周围（上下左右）的陆地放入队列，然后将这块陆地标记为已探索（这里就直接置为'0'了）。
4. 当探险队列为空时，表示这块岛屿的陆地全部被探索完了，我们继续寻找下一块陆地。

**BFS用的是队列---DFS用的是栈，所以直接用递归就可以了，用的系统栈；**

**解法1：DFS**
从一个为1的根节点开始访问，从每个相邻1节点向下访问到顶点（周围全是水），依次访问其他相邻1节点到顶点
时间复杂度 : O(M×N)，其中 M 和 N 分别为行数和列数。
空间复杂度 : 最坏情况下为 O(M×N)，此时整个网格均为陆地，深度优先搜索的深度达到 M×N。

```js
/**
 * 判断岛屿数量
 * @param grid char字符型二维数组 
 * @return int整型
 */
function solve( grid ) {
    // write code here
    var x = grid[0].length;
    var y = grid.length;
    var count = 0;
    if(y == 1 && x == 1) {
        return grid[0][0] == '1';
    }
    const dfs = function(i, j) {
        if(i < 0 || j < 0 || i >= y || j >= x || grid[i][j] == '0'){
            return;
        }
        grid[i][j] = '0';
        dfs(i - 1, j);
        dfs(i + 1, j);
        dfs(i, j - 1);
        dfs(i, j + 1);
    }
    for(let i = 0; i < y; i++) {
        for(let j = 0; j < x; j++){
            if(grid[i][j] == '1'){
                count++;
                dfs(i, j);
            }
        }
    }
    return count;
}
module.exports = {
    solve : solve
};
```

## 找到字符串的最长无重复子串

**题目描述**

给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。

示例1

输入

```
[2,3,4,5]
```

返回值

```
4
```

示例2

输入

```
[2,2,3,4,3]
```

返回值

```
3
```

### Map()

```js
/**
 * 
 * @param arr int整型一维数组 the array
 * @return int整型
 */
function maxLength( arr ) {
    // write code here
    let start = 0 , end = 0;
  let res = 0;
  const map = new Map()
  while(end<arr.length){
    if(map.get(arr[end])>=start){
      start = map.get(arr[end])+1
      map.set(arr[end],end)
    } else {
      map.set(arr[end],end)
      res = Math.max(res, end - start + 1)
    }
    end++
  }
  return res
    
}
module.exports = {
    maxLength : maxLength
};
```

## 换钱的最少货币数

**题目描述**

给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。

如果无解，请返回-1.

【要求】

时间复杂度*O*(*n*×*a**i**m*)，空间复杂度On。

示例1

输入

```
[5,2,3],20
```

返回值

```
4
```

示例2

输入

```
[5,2,3],0
```

返回值

```
0
```

示例3

输入

```
[3,5],2
```

返回值

```
-1
```

### 动态规划

![img](https://www.nowcoder.com/equation?tex=dp_i&preview=true)表示凑成面额i的需要的最少货币数。
然后枚举每个面额的货币，更新dp数组即可。

![img](https://www.nowcoder.com/equation?tex=dp%5Bi%5D%20%3D%20min(dp%5Bi%5D%2C%20dp%5Bi%20-%20a%5Bj%5D%5D)&preview=true)

```js
/**
 * 最少货币数
 * @param arr int整型一维数组 the array
 * @param aim int整型 the target
 * @return int整型
 */
function minMoney( arr ,  aim ) {
    // write code here
    if(!arr || !arr.length) return -1;
    const dp = new Array(aim + 1).fill(Infinity);//把dp数组全部定为最大值
    dp[0] = 0;//初始化数组
    for(let i = 0; i < arr.length; i++) {// 遍历目标值
        for(let j = arr[i]; j <= aim; j++) {// 遍历钱币 如果当前的钱币比目标值小就可以兑换
            //当前的钱数-当前面值，为之前换过的钱数，如果能够兑换只需要在加+1即可，如果不能就取aim+1;
            dp[j] = Math.min(dp[j], dp[j - arr[i]] + 1);
        }
    }
    return dp[aim] === Infinity ? -1 : dp[aim];
}
module.exports = {
    minMoney : minMoney
};
```

# 搜狗

# 问答题

请简述XMLHttpRequest、JSONP的适用场景，并针对两种请求形式简述如何检测请求错误

答：

1. XMLHttpRequest用于浏览器端与服务器端异步请求数据从面实现对页面的无刷新修改，支持GET/POST请求，一般用于非跨域的场景。如果需要使用XMLHttpRequest跨域请求数据，需要通过CORS头支持。 JSONP用于跨域请求数据的场景，只支持GET请求。
2. .XMLHttpRequest异常判断一般通过该对象的readystate和http状态码status来判断，JSONP的异常判断一般是onerror事件和超时timer来判断。

请简述浏览器渲染页面的过程,并给出下方script代码中对哪些CSS属性的"修改"会触发重绘（repaint）和重排（reflow）？

<style>.sg-container {padding: 10px;margin-bottom: 10px;width: 100px; height: 100px;}</style>
<div class="sg-container">
  <p style="line-height:20px">2019搜狗校园招聘</p>
<script>
  document.querySelector('p').style.cssText +='height:10px; line-height:24px;font-size:20px;visibility:hidden;background-color:#00f;border:1px solid #f00';
</script>
</div>

答：

浏览器渲染过程因不同内核可能会有差异，现以webkit为例描述浏览器渲染原理，浏览器渲染过程主要分为三个阶段，先详述如下：
第一阶段：

1. 用户输入URL时，webkit依赖网络模块加载网页或资源数据
2. 网页被交给HTML解释器转变成一系列的词语
3. 解释器根据词语构建节点并形成DOM树
4.  如果节点是CSS、图片、视频等资源，会调用资源加载器加载他们，因该类资源加载是异步的，不会阻塞当前DOM树的继续创建
5. 如果节点是javascript，停止当前DOM树的创建，直到javascript资源加载完成并被javascript引擎执行后才继续进行DOM的创建

第二阶段：

1. CSS解释器解析CSS文件成内部表示结构，并在DOM树上附加样式信息形成RenderObject树
2. RenderObject节点在创建的同时，webkit会根据网页的层次结构创建RenderLayer树，同时创建一个虚拟的绘图上下文

第三阶段：

1. 根据生成的绘图上下文和2D或3D图形库生成最终的图像
   对于包含动画和用户交互的动态网页，浏览器的渲染过程会重复的执行，可能会触发不同程度的重排和重绘。

重排属性：height、line-height、font-size、border
重绘属性：height、line-height、font-size 、border、background-color、visibility

## 检测页面标签

完成一个 getTags 函数，可以检测当前页面用到了哪些标签，函数返回包含标签的字符串的数组，比如页面如下

```
<``html``>`` ``<``head``></``head``>`` ``<``body``>``  ``<``div``></``div``>``  ``<``p``></``p``>`` ``</``body``>``</``html``>
```

注意：

-  1、标签名称使用小写
- 2、请使用ES5语法
- 3、答题时不要使用第三方插件

【解析】

```js
var arrNew = [];
(function getTags() {
    var list1 = document.getElementsByTagName('*');
    for(const key in list1){
        if(list1.hasOwnProperty(key)){
            const element = list1[key];
            arrNew.push(element.tagName);
        }
    }
    arrNew = arrNew.join(',').toLowerCase().split(',');
    console.log(arrNew);
})()
```

## 服务器数据分发

时间限制：C/C++ 5秒，其他语言10秒

空间限制：C/C++ 256M，其他语言512M

【题干描述】：我们共有n台服务器，每台服务器可以和若干个子服务器传输数据，n台服务器组成一个树状结构。现在要将一份数据从root节点开始分发给所有服务器。一次数据传输需要一个小时时间，一个节点可以同时对k个儿子节点进行并行传输，不同节点可以并行分发。问，全部分发完成，最短需要多少小时？
【示例】：当共有5台服务器，其树状结构为    0   /   \  1   2 /  \ 3  4假设每一台服务器同时可以对1个儿子节点（k=1）并行传输，最优的数据传输过程示例如下：  第一个小时，0 -> 1；  第二个小时，1->3 & 0->2；  第三个小时，1 -> 4;所以当k=1时，全部分发完成最短需要3个小时。假设每一台服务器同时可以对2个儿子节点（k=2）并行传输，最优的数据传输过程示例如下：  第一个小时，0 -> 1 & 0 -> 2;  第二个小时，1 -> 3 & 1 -> 4;所以当k=2时，全部分发完成最短需要2个小时。

**输入描述:**

```
首行输入包含两个参数，分别表示每台服务器允许k个子节点并行传输，以及剩余输入行数。
其他行用于服务器树状结构描述，每一行表示一个父节点以及父节点对应的所有子节点。每一行都通过空格符分割不同数字，第一位数字为父节点及其所有子节点个数，第二位数字为父节点编号，其他数字为对应的子节点编号。
```

**输出描述:**

```
输出全部服务器分发完成，需要的最短时间。
```

**输入例子1:**

```
1 2
3 0 1 2
2 1 3
```

**输出例子1:**

```
2
```

```js
var readline = require('readline')
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
})
var inputs = [];
rl.on('line', function(input) {
    inputs.push(input.trim());
    if(inputs[0].split(' ')[1] == inputs.length-1)
    {
        //每找到一个父节点，就让并可发次数加上本身一次
        //计算每行除了父节点的总个数，也就是求除了第一行的inputs的首个元素-1的总和-1
        //然后用总数减去每次找到后的并发数，共计减几次即为几小时
        var pNodeSum = inputs.length-2;
        var nodeSum = 0;
        var hour = inputs[0].split(' ')[0]-0;//-0是快速转化为数字
        var count = 0;
        for(let i = 1;i<inputs.length-1;i++)
            nodeSum+=inputs[i].split(' ')[0]-1;
        for(let j = pNodeSum;j>0;j--)
        {
            nodeSum -= hour;
            hour += hour;
            count++;
        }
        if(nodeSum>0)
            count+=Math.ceil(nodeSum/hour);
        console.log(count);
    }
})
```

# 同盾科技

## 大数相加

题目描述

以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。

（字符串长度不大于100000，保证字符串仅由'0'~'9'这10种字符组成）

示例1

输入

```
"1","99"
```

返回值

```
"100"
```

说明

```
1+99=100 
```

### **前补0**

（1）通过**前补0**的方式，先对齐两个字符串数字的长度, 之后，两两对应位置，进行相加，判断和是否大于10：

（2）大于10则前一位进位加1，本位留个位数字。

（3）小于10则直接相加，留下。

（4）最终检查一下进位是否为1（为1，代表进位，拼接字符串）

最后，返回答案字符串

```js
let a = "9007199254740991";
let b = "1234567899999999999";

function add(a ,b){
   //取两个数字的最大长度
   let maxLength = Math.max(a.length, b.length);
   //用0去补齐长度
   a = a.padStart(maxLength, 0);//"0009007199254740991"
   b = b.padStart(maxLength, 0);//"1234567899999999999"
   //定义加法过程中需要用到的变量
   let t = 0;
   let f = 0;   //"进位"
   let sum = "";
   for(let i = maxLength - 1; i>=0; i--){
      t = parseInt(a[i]) + parseInt(b[i]) + f;
      f = Math.floor(t / 10);
      sum = t % 10 + sum;
   }
   if(f == 1){
      sum = "1" + sum;
   }
   return sum;
}
//运行：

//add(a ,b); //结果为：1243575099254740990
```

### 转换成数组

转换成数组 个位对齐 注意进位

- 将传进来的数字/数字字符串调用toString方法转换成字符串，并进行切割，转成数组
- 判断两个数组的长度，进行值的互换，将splitNum1设置为最长的值，方便后续计算
- carry: 进位值； currentNum: 相加之后，除以10的余数； sum: 相加的值
- 相加，判断是否有进位

```js
function add(strNum1, strNum2) {
  // 将传进来的数字/数字字符串调用toString方法转换成字符串，并进行切割，转成数组
  let splitNum1 = strNum1.toString().split(''),
    splitNum2 = strNum2.toString().split('')

  // 判断两个数组的长度，进行值的互换，将splitNum1设置为最长的值，方便后续计算
  if (splitNum1.length < splitNum2.length) {
    let temp = splitNum1
    splitNum1 = splitNum2
    splitNum2 = temp
  }

  // carry: 进位值； currentNum: 相加之后，除以10的余数； sum: 相加的值
  let len1 = splitNum1.length,
    len2 = splitNum2.length,
    carry = 0,
    currentNum = 0,
    sum = 0

  // len1递减到1之后，循环体中的len1 - 1 = 0 即可拿到下标为零的数组元素，
  // 所以这里条件是 大于 0，下面len2 > 0 同理
  while (len1 > 0) {
    if (len2 > 0) {
      sum = parseInt(splitNum1[len1 - 1]) + parseInt(splitNum2[len2 - 1]) + carry
    } else {
      sum = parseInt(splitNum1[len1 - 1]) + carry
    }
    carry = Math.floor(sum / 10) // 进位数值
    currentNum = sum % 10 // 取余数，作为当前位置的数值
    splitNum1[len1 - 1] = currentNum // 设置当前值

    // 相加之后，数值长度都递减
    len1--
    len2--
  }
  // 判断是否还有进位
  if (carry) {
    splitNum1.unshift(1)
  }
  return splitNum1.join('')
}
let str1 = 123456789;
let str2 = 11;
let result = add(str1, str2)

console.log('result :', result) // result : 11546
```

## 斐波那契数列

**题目描述**

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。

示例1

输入

```
4
```

返回值

```
3
```

### 数学定义

题目分析，斐波那契数列公式为：f[n] = f[n-1] + f[n-2], 初始值f[0]=0, f[1]=1，目标求f[n]

```
function Fibonacci(n)
{
    // write code here
    if(n == 0 || n == 1){
        return n;
    }
    let a = 0, b = 1;
    for(let i = 2; i < n; ++i){
        let c = a + b;
        a = b;
        b = c;
    }
    return a + b;
}
module.exports = {
    Fibonacci : Fibonacci
};
```

**时间复杂度**：O(N)
**空间复杂度**：O(1)

### 数组

```js
function Fibonacci(n)
{
    // write code here
    let fib = [];
    fib[0] = 0;
    fib[1] = 1;
    for(let i = 2; i <= n; i++){
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib[n];
}
module.exports = {
    Fibonacci : Fibonacci
};
```

# 奇安信

## 采购员

**题目描述：**

 1.2020年春节之际，新冠肺炎爆发，国内医疗资源大量紧缺

 2.小明作为一位采购员，被派到国外采购紧缺物资

 3.由于国内需要的物资种类很多，不同品牌种类的物资在疫情中的 使用价值 也不同

 4.在了解商品情况后，小明开始为采购哪些物资才最合适而烦恼。

 5.假如给定了采购预算 T , 每种物资的价格Pn和使用价值 Wn

 6.每种物资的可采购数量不限，你能帮他快速决定出应该采购的物资吗？

 7.要求采购物资的总价格不能超过采购预算

 8.在这个前提下给出的采购列表要使得这批物资的使用价值最大。

 **输入描述:**
 每个测试输入包含一个测试用例
 第一行是总预算(不大于200000)
 第二行是物资种类总数 n (不大于20)
 后面有n行数据， 每一行代表一种物资的价格和使用价值，被空格分成两列， 每列数据值不大于15000

 例如 第3行数据中 第一列是物资1的价格P1, 第二列是物资2的使用价值 W1
 第4行数据中 第一列是物资2的价格 P2, 第二列是物资2的使用价值 W2。
 以此类推，第 n+2 行中第一列是物资 n 的价格 Pn ，第二列是 物资 n 的价格 Wn。

 **输出描述:**
 输出采购物资能达到的最高使用价值，格式是单独的一行 数值

```js
 示例1：
 输入
 100
 5
 77 92
 22 22
 29 36
 50 46
 99 90
 输出
 114
```

 说明
 100预算、5种商品情况下，购买 1个商品一 和 1个商品二 可以达到最大使用价值114

 ```js
示例2：
 输入
 200
 8
 79 83
 58 81
 86 54
 110 1500
 62 52
 45 48
 68 62
 30 22

 输出
 253
 ```

 说明
 200预算、8种商品情况下，购买 1个商品二 、 1个商品四 和 一个商品八 可以达到最大使用价值253

 **备注:**
 **注意：每种物资的可采购数量没有限制**

## 亲7数的个数

**题目描述：**

1.如果一个正整数可以被7整除，我们称之为亲7数

2.对于给出的一组个位数字，请找出使用所有的数字排列出的数中的亲7数的个数。

3.其中给出的个位数字数组中每一个都是不相关的，即使有重复的数字

4.如{1，1，2}排列出的数为{**112，121，112，121，211，211**}， 亲7数为{112，112}共2个。

输入：个位数字数组，数组有m个元素

输出：亲7数个数

示例1:
输入
[1,1,2]

输出
2

### 暴力 + 回溯

```js
def permutation(digit):
    s= []
    for i in digit:
        s.append(str(i))
        c, res = list(s), []
    def dfs(x):
        if x == len(c) - 1:
            res.append(''.join(c)) # 添加排列方案
            return 
        dic = []
        for i in range(x, len(c)):
            #if c[i] in dic: continue # 重复，因此剪枝
            dic.append(c[i])
            c[i], c[x] = c[x], c[i] # 交换，将 c[i] 固定在第 x 位
            dfs(x + 1) # 开启固定第 x + 1 位字符
            c[i], c[x] = c[x], c[i] # 恢复交换
    dfs(0)
    result = []
    for i in res:
        if int(i) % 7 == 0:
            result.append((int(i)))

    return len(result)
permutation([1,1,2])
>> 2
```

### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度中等

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

**搜索回溯**

```js
const permuteUnique = (nums) => {
  const res = [];
  const len = nums.length;
  const used = new Array(len);
  nums.sort((a, b) => a - b); // 升序排序

  const helper = (path) => {
    if (path.length == len) { // 个数选够了
      res.push(path.slice()); // path的拷贝 加入解集
      return;                 // 结束当前递归 结束当前分支
    }

    for (let i = 0; i < len; i++) { // 枚举出所有的选择
      if (nums[i - 1] == nums[i] && i - 1 >= 0 && !used[i - 1]) { // 避免产生重复的排列
        continue;
      }
      if (used[i]) {      // 这个数使用过了，跳过。
        continue;
      }
      path.push(nums[i]); // make a choice
      used[i] = true;     // 记录路径上做过的选择
      helper(path);       // explore，基于它继续选，递归
      path.pop();         // undo the choice
      used[i] = false;    // 也要撤销一下对它的记录
    }
  };

  helper([]);
  return res;
};
```

- 时间复杂度：*O*(*n*×*n*!)
- 空间复杂度：O(n)。我们需要 O(n)的标记数组，同时在递归的时候栈深度会达到 O(n)，因此总空间复杂度为 O(n + n)=O(2n)=O(n)

# CVTE

## 两数之和

**题目描述**

给出一个整数数组，请在数组中找出两个加起来等于目标值的数，

你给出的函数twoSum 需要返回这两个数字的下标（index1，index2），需要满足 index1 小于index2.。注意：下标是从1开始的

假设给出的数组中只存在唯一解

例如：

给出的数组为 {20, 70, 110, 150},目标值为90
输出 index1=1, index2=2

示例1

输入

```
[3,2,4],6
```

返回值

```
[2,3]
```

### **HashMap**

**解题思路**：利用HashMap存储数在numbers[]数组中的值和下标，然后通过for循环遍历数组，当前数为numbers[i]，如果target - numbers[i]等于在HashMap中的key值，那么说明数组中存在两个和为target的数，返回值在数组中的下标。如果不存在就返回null。注意：返回的下标从1开始。

```js
/**
  * 
  * @param numbers int整型一维数组 
  * @param target int整型 
  * @return int整型一维数组
  */
function twoSum (numbers, target) {
    const map = new Map();
    const len = numbers.length;
    for(let i = 0; i < len; i++){
        if(map.has(target - numbers[i])){//如果hashmap中包含target - numbers[i]，则找到这两个数，返回下标
            return [map.get(target - numbers[i]) + 1,i + 1];//注意：返回的下标要从1开始
        }else{
            map.set(numbers[i], i);//将numbers[]数组中的值和下标存入hashmap中
        }
    }
};
module.exports = {
    twoSum : twoSum
};
```

# 小米

## 寻找第K大

**题目描述**

有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。

给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。

示例1

输入

```
[1,3,5,2,2],5,3
```

返回值

```
2
```

### 快排+二分

快排+二分，与快排不同的是，利用二分法每次都减少了一半的不必要排序。

```js
/**
 * 
 * @param a int整型一维数组 
 * @param n int整型 
 * @param K int整型 
 * @return int整型
 */
function findKth( a ,  n ,  K ) {
    let result = 0;
    function sort (arr, left, right, k) {
        if (left > right) {
            return;
        }
        let base = arr[left];
        let i = left;
        let j = right;
        while (j > i) {
            while ((j > i) && (arr[j] <= base)) {
                j--;
            }
            arr[i] = arr[j];
            while ((j > i) && (arr[i] >= base)) {
                i++;
            }
            arr[j] = arr[i];
        }
        arr[i] = base;
        result = base;
        if (i === k - 1) {
            return;
        } else if (i > k - 1) {
            sort(arr, left, i - 1, k);
        } else if (i < k - 1) {
            sort(arr, j + 1, right, k);
        }
    }
    sort(a, 0, n - 1, K);
    return result;
}
module.exports = {
    findKth : findKth
};
```

### 库函数

```js
/**
 * 
 * @param a int整型一维数组 
 * @param n int整型 
 * @param K int整型 
 * @return int整型
 */
function findKth( a ,  n ,  K ) {
    // write code here
    a.sort((a,b)=>b-a);
    return a[K-1]
}
module.exports = {
    findKth : findKth
};
```

## 二分查找

**题目描述**

请实现有重复数字的有序数组的二分查找。

输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。

示例1

输入

```
5,4,[1,2,4,4,5]
```

返回值

```
3
```

说明

```
输出位置从1开始计算 
```

**解题思路**：采用二分查找的思想解决问题，首先用两个指针标记左、右，然后用mid所指的位置与关键字比较。若小于关键字，则在其右侧二分查找left = mid+1；若大于等于关键字，则继续在mid的左侧二分查找 result = mid + 1; right = mid。

```js
/**
 * 二分查找
 * @param n int整型 数组长度
 * @param v int整型 查找值
 * @param a int整型一维数组 有序数组
 * @return int整型
 */
function upper_bound_( n ,  v ,  a ) {
           if(a[n-1] < v){
                return n+1;
            }
            let left = 0;
            let right = n-1;
            let result = n+1;
            while(left<right){
                let mid = Math.floor((left + right)/2);
                if(a[mid] >= v){ //如果数组中的元素大于目标值，那结果就加1
                    result = mid + 1;
                    right = mid;
                }else{
                    left = mid+1;
                }
            }
            return result
}
module.exports = {
    upper_bound_ : upper_bound_
};
```

## 括号序列

**题目描述**

给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

示例1

输入

```
"["
```

返回值

```
false
```

示例2

输入

```
"[]"
```

返回值

```
true
```

### Map()

- 边遍历边匹配。也就是遍历的时候遇到左括号存入数组，下次遇到的第一个右括号必须和数组中最后一个元素匹配，否则为无效字符串，匹配完成后从数组中删除此元素。
- 若最终数组为空，表示括号已全部匹配完，字符串有效。

```js
/**
  * 
  * @param s string字符串 
  * @return bool布尔型
  */
function isValid( s ) {
    // write code here
    const map = {
        "{": "}",
        "[": "]",
        "(": ")"
    }
    let leftArr = [];
    for (var ch of s) {
        if (ch in map) leftArr.push(ch);//为左括号时，顺序保存
        else {//为右括号时，与数组末位匹配
            if (ch != map[leftArr.pop()]) return false;
        }
    }
    return !leftArr.length;//防止全部为左括号
}
module.exports = {
    isValid : isValid
};
```

## 找到字符串的最长无重复字符字串

**题目描述**

给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。

示例1

输入

```
[2,3,4,5]
```

返回值

```
4
```

示例2

输入

```
[2,2,3,4,3]
```

返回值

```
3
```

备注:

```
1≤n≤105
```

### 双指针+map()

```js
/**
 * 
 * @param arr int整型一维数组 the array
 * @return int整型
 */
function maxLength( arr ) {
    // write code here
    let start = 0, end = 0;
    let res = 0;
    const map = new Map();
    while(end < arr.length) {
        if(map.get(arr[end]) >= start) {
            start = map.get(arr[end]) + 1;
            map.set(arr[end], end);
        }else {
            map.set(arr[end], end);
            res = Math.max(res, end - start + 1);
        }
        end++;
    }
    return res;
}
module.exports = {
    maxLength : maxLength
};
```

# 北森

## 第一次只出现一次的字符

**题目描述**

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

示例1

输入

```
"google"
```

返回值

```
4
```

### map两次遍历

遍历字符串，将每个字符的值与出现次数记录到 map 中
再次遍历 map.keys() ，获取 map 中每个字符出现的次数，判断是否仅仅只有 1 次，返回第一个仅出现一次的字符

```js
var firstUniqChar = function(s) {
    if(!s) return " "
    let map = new Map()
    for(let c of s) {
        if(map.has(c)) {
            map.set(c, map.get(c) + 1)
        } else {
            map.set(c, 1)
        }
    }
    for(let c of map.keys()) {
        if(map.get(c) === 1) {
            return c
        }
    }

    return  -1
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

# 森亿智能

## 对象深拷贝

对列表dict_list = [{"a": "aa", "b": "bb"}, {"c": 123, "d": 456}] 中的字典的key, value 各自输出到列表中

```js
//获取vkey
function deepKeys(object) {
    var keys = [];
    if (object instanceof Array) {
        for (let i = 0; i < object.length; i++) {
            for (var property in object[i]) {
                keys.push(property);
            }
        }
    }
    return keys;
}
//获取valus
function deepValues(object) {
    var keys = [];
    if (object instanceof Array) {
        for (let i = 0; i < object.length; i++) {
            for (var property in object[i]) {
                keys.push(object[i][property]);
            }
        }
    }
    return keys;
}

//测试
var dict_list = [{
    "a": "aa",
    "b": "bb"
}, {
    "c": 123,
    "d": 456
}]
console.log(deepKeys(dict_list))
console.log(deepValues(dict_list))
```

## 变换日期格式

**YYYY/MM/DD->YYYY/DDD**

最常使用到的日期表示格式是：YYYY/MM/DD，如：2019/12/05。

含义：年份用4位数字表示、2位月份用2位数字表示、日期用2位数字表示。

还有一种比较少见的日期表示格式是：YYYY/DDD，它的含义是：代表年份用4位数字，之后的3位数字，代表是这一年中的第几天。

如：2019/01/01表示2019/001；2019/01/31表示为2019/031；

问题：需要实现一个功能，输入YYYY/MM/DD格式的日期。经过转换后的输出YYYY/DDD格式的结果。如：输入2019/02/01，经过转换后返回的输出结果为2019/032。

请描述一下你对实现这个功能的思路。（可以使用自然语言描述、伪代码描述、或自己熟悉的程序描述）

```js
function format(str) {
    // 以'/'分割字符串为数组
    let arr = str.split('/');
    let year = arr[0];
    let month = arr[1];
    let days = arr[2];
    // monthDays：所在月份之前的月份天数之和
    let monthDays = 0;
    let arrDate;
    // 对月份的天数进行累加
    for (let i = 0; i < month - 1; i++) {
        // new Date(year, i, 0); // 根据月份设置日期
        arrDate = new Date(arr[0], i, 0)
        console.log(arrDate.getDate())
        monthDays += arrDate.getDate() // 根据设置的日期来获取月份的天数,获得是标准时间,需要getDate()获得天数
    }
    let sum = monthDays + parseInt(arr[2]);
    // 小于100前补0
    if (sum < 10) {
        sum = '00' + sum;
    } else if (sum < 100) {
        sum = '0' + sum;
    }
    let strDay = arr[0] + '/' + sum;
    console.log(strDay);;
}
// 测试
let str = '2019/01/31';
format(str)

```

# 好未来

## 求出数组中元素的最大差值

```js
function getMaxDiff( arr ) {
    // write code here
    let max = Math.max(...arr);
    let min = Math.min(...arr);
    return max-min
}
let arr = [1,3,5,8]
console.log(getMaxDiff(arr))
```

## 最长的无重复子串

### Map()

**解题思路**使用 map 来存储当前已经遍历过的字符，key 为字符，value 为下标

使用 start 来标记无重复子串开始下标，end 为当前遍历字符下标

遍历字符串，判断当前字符是否已经在 map 中存在，存在则更新无重复子串开始下标 start 为相同字符的下一位置，此时从 start 到 end 为最新的无重复子串，更新 max ，将当前字符与下标放入 map 中

最后，返回 max 即可

```js
var lengthOfLongestSubstring = function(s) {
 	let map = new Map(), max = 0;
    // 使用 start 来标记无重复子串开始下标，end 为当前遍历字符下标
    for (let end = 0, start = 0; end < s.length; end++) {
        // 判断当前字符是否已经在 map 中存在
        if(map.has(s[end])) {
            // 存在则更新无重复子串开始下标 start 为相同字符的下一位置
            start = Math.max(map.get(s[end]) + 1, start);
        }
        max = Math.max(max, end - start + 1);
        map.set(s[end], end);
    }
    return max;
};
```

**时间复杂度：O(n)**

**空间复杂度：O(n)**

# 字节跳动

## 排序

**题目描述**

给定一个数组，请你编写一个函数，返回该数组排序后的形式。

示例1

**输入**

```
[5,2,3,1,4]
```

**返回值**

```
[1,2,3,4,5]
```

示例2

**输入**

```
[5,1,6,2,5]
```

**返回值**

```
[1,2,5,5,6]
```

**备注:**

```
数组的长度不大于100000，数组中每个数的绝对值不超过10^9109
```

###快速排序

**解题思路**：两个移动的指针和一个基准值，一次排序后应达到基准值是一个分水岭，按从小到大排序，左边应该比基准值小，右边应该比基准值大。基本思路是：开始left不动，如果right指向的值大于等于基准值（基准值的大小可以等于一开始left指向的值），就right--；如果不满足上述条件，就right指向的值赋给left，同时left++；如果left指向的值小于等于基准值，就left++；如果不满足，就left指向的值赋给right，同时right--；循环结束条件：left<rigth。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    // write code here
  const sort = (array, left = 0, right = arr.length - 1) => {
    if (left >= right) {
      return;
    }
    let i = left;
    let j = right;
    const baseVal = array[j];
    while (i < j) {
      while (i < j && array[i] <= baseVal) {
        i++;
      }
      array[j] = array[i];
      while (i < j && array[j] >= baseVal) {
        j--;
      }
      array[i] = array[j];
    }
    array[j] = baseVal;
    sort(array, left, j - 1);
    sort(array, j + 1, right);
  }
  const newArr = arr.concat();
  sort(newArr);
  return newArr;
}
module.exports = {
    MySort : MySort
};
```

### 归并排序MergeSort

- 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。
- 归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    // write code here
    mergeSort(arr,0,arr.length-1);
    return arr;
}
function mergeSort(arr, l, r) {
      if(l==r){
          return;
      }
      var mid = l+((r-l)>>1); //中点位置，即(l+r)/2
      mergeSort(arr,l,mid);
      mergeSort(arr,mid+1,r);
      merge(arr,l,mid,r);
}
 function merge(arr, l, mid, r){
      var help= [];    //辅助数组
      var i=0;
      var p1=l; //左半数组的下标
      var p2=mid+1; //右半数组的下标
 
      //判断是否越界
      while(p1<=mid && p2<=r){
          help[i++]=arr[p1]<arr[p2] ? arr[p1++] : arr[p2++];
      }
      //p1没有越界，说明p2越界了，将左边剩余元素拷贝到辅助数组
      while(p1<=mid){
          help[i++]=arr[p1++];
      }
      //p2没有越界，说明p1越界了
      while(p2<=r){
          help[i++]=arr[p2++];
      }
      //将辅助数组元素拷贝会原数组
      for(i=0;i<help.length;i++){
          arr[l+i]=help[i];
      }
  }
module.exports = {
    MySort : MySort
};
```

### **冒泡排序BubbleSort**

**以升序排列为例：**将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。
**时间复杂度：**
若原数组本身就是有序的（这是最好情况），仅需n-1次比较就可完成，时间复杂度依然为O(n）；
若是倒序，比较次数为 n-1+n-2+...+1=n(n-1)/2，交换次数和比较次数等值。所以，其时间复杂度依然为O(n2）
**空间复杂度：**
使用常数个辅助单元：O(1）

运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。

用例通过率：20.00%

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    if (arr.length <= 1) return
    for (let i = 0; i < arr.length; i++) {
        let hasChange = false
        for (let j = 0; j < arr.length - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                const temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
                hasChange = true
            }
        }
        // 如果false 说明所有元素已经到位
        if (!hasChange) break
    }
    return arr
}
module.exports = {
    MySort : MySort
};
```

### 插入排序

**解题思路**首先，我们将数组中的数据分为两个区间， 已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据a插入到已排序区间时，需要拿a与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 插入  

**空间复杂度**

插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)  

**时间复杂度**

如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为O(n)。注意，这里是从尾到头遍历已经有序的数据。
如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度O(n2)。
还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n2)  

运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。

用例通过率：20.00%

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    // write code here
    if (arr.length <= 1) return
    for (let i = 1; i < arr.length; i++) {
        const temp = arr[i]
        let j = i - 1
        // 若arr[i]前有大于arr[i]的值的化，向后移位，腾出空间，直到一个<=arr[i]的值
        for (j; j >= 0; j--) {
            if (arr[j] > temp) {
                arr[j + 1] = arr[j]
            } else {
                break
            }
        }
        arr[j + 1] = temp
    }
    return arr;
}
module.exports = {
    MySort : MySort
};
```

###  选择排序

选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。  

选择排序空间复杂度为O(1)  

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。  

```js
const selectionSort = (arr) => {
    if (arr.length <= 1) return
    // 需要注意这里的边界, 因为需要在内层进行 i+1后的循环，所以外层需要 数组长度-1
    for (let i = 0; i < arr.length - 1; i++) {
        let minIndex = i
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j // 找到整个数组的最小值
            }
        }
        const temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
    }
    console.log(arr)
}
```

### 库函数

```js
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 * 将给定数组排序
 * @param arr int整型一维数组 待排序的数组
 * @return int整型一维数组
 */
function MySort( arr ) {
    // write code here
    return arr.sort((a, b) => a - b);
}
module.exports = {
    MySort : MySort
};
```

## 单链表的排序

**题目描述**

给定一个无序单链表，实现单链表的排序(按升序排序)。

示例1

输入

```
[1,3,2,4,5]
```

返回值

```
{1,2,3,4,5}
```

**选择排序**的大体思路就是先建立已排序区和未排序区（初始状态已排序区为空，未排序区为整个单向链表），循环遍历未排序区找到最小的元素并移动到已排序区的末尾（从未排序区删除）

**解题思路**

1. 先存储链表中各个节点
2. 使用 sort 进行排序
3. 将  ListNode 按顺序串联起来

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 the head node
 * @return ListNode类
 */
function sortInList( head ) {
    // write code here
    if(!head) return;
    let arr = [];
    let node = head;
    while(node){
        arr.push(node.val);
        node = node.next;
    }
    arr.sort((a,b) => a - b);
    node = head;
    for(let item of arr){
        node.val = item;
        node = node.next;
    }
    return head;
}
module.exports = {
    sortInList : sortInList
};
```

## 进制转换

**题目描述**

给定一个十进制数M，以及需要转换的进制数N。将十进制数M转化为N进制数

示例1

输入

```
7,2
```

返回值

```
"111"
```

备注:

```
M是32位整数，2<=N<=16.
```

```js
/**
 * 进制转换
 * @param M int整型 给定整数
 * @param N int整型 转换到的进制
 * @return string字符串
 */
function solve( M ,  N ) {
    // write code here
   const reg = /[a-z]/;
   const str = M.toString(N);
    let res = '';
    for (let item of str) {
        if (reg.test(item)) {
            item = item.toUpperCase();
        }
        res += item;
    }
    return res;
}
module.exports = {
    solve : solve
};
```

## 合并两个有序的数组

给出两个有序的整数数组 ![img](https://www.nowcoder.com/equation?tex=A%20%5C)和 ![img](https://www.nowcoder.com/equation?tex=B%5C)，请将数组 ![img](https://www.nowcoder.com/equation?tex=B%5C)合并到数组 ![img](https://www.nowcoder.com/equation?tex=A%5C)中，变成一个有序的数组
注意：
可以假设 ![img](https://www.nowcoder.com/equation?tex=A%5C)数组有足够的空间存放 ![img](https://www.nowcoder.com/equation?tex=B%5C)数组的元素， ![img](https://www.nowcoder.com/equation?tex=A%5C)和 ![img](https://www.nowcoder.com/equation?tex=B%5C)中初始的元素数目分别为 ![img](https://www.nowcoder.com/equation?tex=m%5C)和 n

### **归并排序**

**思路:**

1. 从A和B的m、n尾部遍历
2. 比较A和B的m、n尾部的值，将较大值赋给A整体数组的尾部，指针左移
3. 注意特殊情况处理：A的尾指针已遍历结束，B尾指针还未结束。

```js
/**
 * 
 * @param A int整型一维数组 
 * @param B int整型一维数组 
 * @return void
 */
function merge( A, m, B, n ) {
    // write code here
    let len = m + n
    while(n > 0 && m > 0) {
        if (A[m - 1] > B[n - 1]) {//如果A的m尾部的值大
            A[--len] = A[--m]
        } else {
            A[--len] = B[--n]
        }
    }
    while(n) {//如果B没有遍历完，那么之间丢在A数组里面
        A[--len] = B[--n]
    }
    return A
}
module.exports = {
    merge : merge
};
```

## 求路径

**题目描述**

一个机器人在m×n大小的地图的左上角（起点）。

机器人每次向下或向右移动。机器人要到达地图的右下角（终点）。

可以有多少种不同的路径从起点走到终点？

![img](https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7)

备注：m和n小于等于100,并保证计算结果在int范围内

示例1

输入

```
2,1
```

返回值

```
1
```

示例2

输入

```
2,2
```

返回值

```
2
```

```js
/**
  * 
  * @param m int整型 
  * @param n int整型 
  * @return int整型
  */
function uniquePaths( m ,  n ) {
    // write code here
  //可以直接使用递归
  //使用动态规划的话就需要知道每一个格子都有几种可能
  //最后维护好这个数组，最后一个数就是我们要求的值
  let dp = []
  for(let i = 0; i <= m; i++){
    let arr = new Array(n+1).fill(0)
    dp[i] = arr
  }
  //这边给
  dp[0][1] = 1
  for(let i = 1; i < m+1; i++){
    for(let j = 1; j < n+1; j++){
      dp[i][j] = dp[i-1][j] + dp[i][j-1]
    }
  }
  return dp[m][n]
}
module.exports = {
    uniquePaths : uniquePaths
};
```

## 判断链表中是否有环

**题目描述**

判断给定的链表中是否有环。如果有环则返回true，否则返回false。

你能给出空间复杂度![img](https://www.nowcoder.com/equation?tex=O(1)%5C)的解法么？

### 快慢指针

快慢指针的解法， 一个指针走两步 一个指针走一步，如果快指针直接到了null 说明没有环， 如果有环的话 总有一次结果会让快指针和慢指针相等。

```js
/*
 * function ListNode(x){
 *   this.val = x;
 *   this.next = null;
 * }
 */

/**
 * 
 * @param head ListNode类 
 * @return bool布尔型
 */
function hasCycle( head ) {
    // write code here
    //快慢两个指针
    let fast = head;
    let slow = head;
    while(fast && fast.next ){
        //快指针每次走两步
        fast = fast.next.next;
         //慢指针每次走一步
        slow = slow.next;
        //如果相遇，说明有环，直接返回true
        if(fast == slow){
            return true;
        }
    }
    //否则就是没环
    return false
}
module.exports = {
    hasCycle : hasCycle
};
```

## 缺失数字

**题目描述**

从0,1,2,...,n这n+1个数中选择n个数，组成有序数组，找出这n个数中缺失的那个数，要求O(n)尽可能小。

示例1

输入

```
[0,1,2,3,4,5,7]
```

返回值

```
6
```

### 求和公式

- ![formula](https://dss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1343439641,1599196105&fm=58)
- ![formula](https://dss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2009555104,3930307475&fm=58)

**思路**：因为 ![0-n](https://www.nowcoder.com/equation?tex=0%20-%20n) 个数里面只缺少一个数，所以可以直接对 ![0-n](https://www.nowcoder.com/equation?tex=0%20-%20n) 求和，然后再减去![a](https://www.nowcoder.com/equation?tex=a) 数组的和就是答案了。

```js
/**
 * 找缺失数字
 * @param a int整型一维数组 给定的数字串
 * @return int整型
 */
function solve( a ) {
    // write code here
    let aLen = a.length;
    let presum = aLen * (aLen + 1) / 2;//求和公式
    let sum = 0;
    for (let i = 0; i < aLen; i++) {
        sum += a[i];
    }
    return presum - sum;
}
module.exports = {
    solve : solve
};
```

时间复杂度：![图片说明](https://www.nowcoder.com/equation?tex=O(n))

### 二分查找

因为缺失了 一个数字 所以 下标指向数组的值 一定是 大于或者等于 当前 下标的
所以采用 二分的方法 逐个的去逼近 缺失的值
无非就是两种情况
第一种：下标指向的值 等于 当前的下标，那么 缺失的肯定是在当前下标的右侧，所以left=mid+1
第二钟：下标指向的值 大于 当前的下标，那么 缺失的肯定是在mid的左侧，所以right=mid
最后逼近到 left = mid + 1的时候 mid的左侧都是不确实的，mid+1就正好是缺失的值
并且此时 left == right 所以跳出循环 返回正确的答案

```js
/**
 * 找缺失数字
 * @param a int整型一维数组 给定的数字串
 * @return int整型
 */
function solve( a ) {
    // write code here
    let left = 0,right = a.length;
    while (left < right) {
        const mid = left + Math.floor((right - left) / 2);
        //相等的情况 结果只会出现在 mid 右侧
        if (a[mid] === mid) {
            left = mid + 1;
        }else if (a[mid] > mid) {//只会出现 所在下标的取值 大于等于 当前 下标
            right = mid;
        }
    }
    return left;
}
module.exports = {
    solve : solve
};
```

## 容器盛水问题

**题目描述**

给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。

具体请参考样例解释

示例1

输入

```
[3,1,2,5,2,4]
```

返回值

```
5
```

说明

```
 
```

示例2

输入

```
[4,5,1,3,2]
```

返回值

```
2
```

说明

<img src="https://uploadfiles.nowcoder.com/images/20200628/323944_1593310519156_4DCDFB8E8F161D1221ECC67C3E7A88F6">

### 双指针

把数组分成两边来看
l_max存储的是上一个左边较大的，r_max存储的是上一个右边较大的，哪个比较小，就先装哪边的水。
装水过程 `val += leftMax - arr[left++]`或`val += rightMax - arr[right--];`

```js
/**
 * max water
 * @param arr int整型一维数组 the array
 * @return long长整型
 */
function maxWater( arr ) {
    // write code here
    if(!arr) return;
    let val = 0;
    let left = 0, right = arr.length - 1;
    let leftMax = 0, rightMax = 0;
    while(left < right){
        leftMax = Math.max(arr[left],leftMax);
        rightMax = Math.max(arr[right], rightMax);
        if(leftMax <= rightMax){
            val += leftMax - arr[left++];
        }else{
            val += rightMax - arr[right--];       
        }
    }
    return val
    
}
module.exports = {
    maxWater : maxWater
};
```

## 在转动过的有序数组中寻找目标值

**题目描述**

给出一个转动过的有序数组，你事先不知道该数组转动了多少
(例如,0 1 2 4 5 6 7可能变为4 5 6 7 0 1 2).
在数组中搜索给出的目标值，如果能在数组中找到，返回它的索引，否则返回-1。
假设数组中不存在重复项。

示例1

输入

```
[1],0
```

返回值

```
-1
```

示例2

输入

```
[3,2,1],1
```

返回值

```
2
```

**暴力解法**

```js
/**
  * 
  * @param A int整型一维数组 
  * @param target int整型 
  * @return int整型
  */
function search( A ,  target ) {
    // write code here
    for(var i = 0; i < A.length; i++){
        if(A[i] == target) return i;
    }
    return -1;
}
module.exports = {
    search : search
};
```

### 二分查找

- 先判断是否发生旋转，判断旋转的依据就是数组的第一个值大于最后一个值。
- 如果没有发生旋转，直接用二分查找
- 如果发生了旋转，找出旋转点，确定了两个有序的子数组，然后在有序的子数组中进行二分查找。while循环结束，left对应的是最大值，right对应的是最小值。

```js
/**
  * 
  * @param A int整型一维数组 
  * @param target int整型 
  * @return int整型
  */
function search( A ,  target ) {
    // write code here
    let index = -1;
    let left  = 0;
    let right = A.length - 1;
    
    // 没有旋转
    if (A[left] <= A[right]) {
        return binarySearch(A, left , right, target);
    } else {
        // 有旋转，找到旋转点，确定两个有序子数组
        while (A[left] > A[right]) {
            let mid = (left + right) >> 1;
            if (A[mid] > A[left]) {
                left = mid;
            } else {
                right = mid;
            }
        }
        if (target >= A[0]) {
            return binarySearch(A,0,left,target);
        } else {
            return binarySearch(A,left + 1,A.length - 1,target);
        }
    }  
}
function binarySearch(A, left, right, target) {
    if (A == null || A.length == 0) {
        return -1;
    }
    while (left <= right) {
        let mid = (left + right) >> 1;
        if (target < A[mid]) {
            right  = mid -1;
        } else if (target > A[mid]) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}
module.exports = {
    search : search
};
```

## 最长递增子序列

**题目描述**

给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）

示例1

输入

```
[2,1,5,3,6,4,8,9,7]
```

返回值

```
[1,3,4,8,9]
```

示例2

输入

```
[1,2,8,6,4]
```

返回值

```
[1,2,4]
```

说明

```
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个字典序最小，故答案为（1，2，4）
```

```js
/**
 * retrun the longest increasing subsequence
 * @param arr int整型一维数组 the array
 * @return int整型一维数组
 */
function LIS( arr ) {
    // write code here
    let length = arr.length;
    let end = new Array(length+1);
    let dp = new Array(length);
    let n = 1;
    end[1] = arr[0];
    dp[0] = 1;
    for(let i=0;i<length;i++) {
        if(end[n] < arr[i]) {
            end[++n] = arr[i];
            dp[i] = n;
        } else {
            let left = 0;
            let right = n;
            while(left<=right) {
                let mid = left + Math.floor((right-left)/2);
                if(end[mid] >= arr[i]) {
                    right = mid-1;
                } else {
                    left = mid + 1;
                }
            }
            end[left] = arr[i];
            dp[i] = left;
        }
    }
    let res = new Array(n);
    for(let i=length-1;i>=0;i--) {
        if(dp[i] === n) {
            res[--n] = arr[i];
        }
    }
    return res;
    
}
module.exports = {
    LIS : LIS
};
```

## 跳台阶

**题目描述**

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

示例1

输入

```
1
```

返回值

```
1
```

示例2

输入

```
4
```

返回值

```
5
```

```js
function jumpFloor(number)
{
    // write code here
    if(number == 0) return 1;
    if(number == 1 || number == 2) return number;
    let f1 = 1, f2 = 2, f3 = 0;
    while(number > 2){
        f3 = f1 + f2;
        f1 = f2;
        f2 = f3;
        number--;
    }
    return f2;
}
module.exports = {
    jumpFloor : jumpFloor
};
```

```js
function jumpFloor(number)
{
    // write code here
    let arr = [1,1];
    for(let i = 2; i <= number; i++) {
        arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr[number];
}
module.exports = {
    jumpFloor : jumpFloor
};
```

### 动态规划

```js
function jumpFloor(number)
{
    // write code here
    var dp = new Array(number + 1);
    dp[0] = 1;
    dp[1] = 1;
    for(var i = 2; i <= number; i++){
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[number];
}
module.exports = {
    jumpFloor : jumpFloor
};
```

## 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

示例1

输入

```
[1,2,3,4,5,6,7],[3,2,4,1,6,5,7]
```

返回值

```
{1,2,5,3,4,6,7}
```

### 递归

二叉树的前序遍历：根左右
二叉树的中序遍历：左根右
二叉树的的后序遍历：左右根

根据前序遍历/后序遍历+中序遍历可以重建一个二叉树，这道题考察的就是前序遍历+中序遍历重建二叉树。
对于

```js
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

前序遍历中的3即为根节点的值，由于输入的前序遍历和后序遍历的结果中都不含重复的数字，那么在中序遍历中，3
前面的节点都是左子树上的节点，3后面的节点都是右子树上的节点，这一步可以获得根节点和左右两个子树，再递归地对左右子树进行
重建，即可构建出一个新的二叉树。

```js
function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
}
function reConstructBinaryTree(preorder, inorder)
{
    if (!preorder.length || !inorder.length) return null
    let root = preorder[0]; // 前序遍历的第一个元素为根节点
    let node = new TreeNode(root); // 确定根节点

    let i = inorder.indexOf(root); // 获取根节点在中序遍历中的位置(用于分割左右子树)

    // preorder.slice(1,index+1)是左子树的前序遍历
    // inorder.slice(0,index) 是左子树的中序遍历
    // 这一步递归的对左子树进行重建
    node.left = reConstructBinaryTree(preorder.slice(1, i + 1), inorder.slice(0, i));
    node.right = reConstructBinaryTree(preorder.slice(i + 1), inorder.slice(i + 1));
    return node
}
module.exports = {
    reConstructBinaryTree : reConstructBinaryTree
};

```

## 实现二叉树先序，中序和后序遍历

**题目描述**

分别按照二叉树先序，中序和后序打印所有的节点。

示例1

输入

```
{1,2,3}
```

返回值

```
[[1,2,3],[2,1,3],[2,3,1]]
```

### 递归

先序：根左右
中序：左根右
后序：左右根

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */

/**
 * 
 * @param root TreeNode类 the root of binary tree
 * @return int整型二维数组
 */
function threeOrders( root ) {
    // write code here
    let preArray = [], middleArray = [], postArray = [];
    function preOrder(root) {
        if (root) {
            preArray.push(root.val)
            preOrder(root.left)
            preOrder(root.right)
        }
    }
    function inOrder(root) {
        if (root) {
            inOrder(root.left)
            middleArray.push(root.val)
            inOrder(root.right)
        }
    }
    function postOrder(root) {
        if (root) {
            postOrder(root.left)
            postOrder(root.right)
            postArray.push(root.val)
        }
    }
    preOrder(root)
    inOrder(root)
    postOrder(root)
    return [preArray, middleArray, postArray]
}
module.exports = {
    threeOrders : threeOrders
};
```

```js
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */

/**
 * 
 * @param root TreeNode类 the root of binary tree
 * @return int整型二维数组
 */
function threeOrders( root ) {
    // write code here
    let preOrder = [], inOrder = [], postOrder = [];
    function find(root) {
        if(!root) return null;
        preOrder.push(root.val); // 先序：根左右
        find(root.left);
        inOrder.push(root.val); // 中序：左根右
        find(root.right);
        postOrder.push(root.val); // 后序：左右根
    }
    find(root);
    return [preOrder, inOrder, postOrder];
}
module.exports = {
    threeOrders : threeOrders
};
```

## 买卖股票的最好时机

**题目描述**

假设你有一个数组，其中第\ i *i* 个元素是股票在第\ i *i* 天的价格。
你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。

示例1

输入

```
[1,4,2]
```

返回值

```
3
```

示例2

输入

```
[2,4,1]
```

返回值

```
2
```

### 贪心

```js
/**
  * 
  * @param prices int整型一维数组 
  * @return int整型
  */
function maxProfit( prices ) {
    // write code here
    let minVal = prices[0], profit = 0;
    for(let i = 1; i < prices.length; ++i) {
        if(prices[i] < minVal){
            minVal = prices[i];
        }
        profit = Math.max(profit, prices[i] - minVal);
    }
    return profit;
}
module.exports = {
    maxProfit : maxProfit
};
```

### 动态规划

```js
/**
  * 
  * @param prices int整型一维数组 
  * @return int整型
  */
function maxProfit( prices ) {
    // write code here
    // 买卖股票的最大收益
    // 使用动态规划实现
        let n = prices.length;
        if(!n) return 0;
        // 前i只最多交易1次的最大利润
        let dp = new Array(n).fill(0);
        for(let i = 1, minv = prices[0]; i < n; i++){
            dp[i] = Math.max(dp[i-1], prices[i] - minv);
            minv = Math.min(prices[i],minv);
        }
        return dp[n-1];
}
module.exports = {
    maxProfit : maxProfit
};
```

## 将字符串转化为整数

**题目描述**

实现函数 atoi 。函数的功能为将字符串转化为整数

提示：仔细思考所有可能的输入情况。这个问题没有给出输入的限制，你需要自己考虑所有可能的情况。

示例1

输入

```
"123"
```

返回值

```
123
```

1. 处理空字符串
2. 忽略前置空格
3. 保存符号
4. 处理非法输入
5. 处理溢出

```js
/**
  * 
  * @param str string字符串 
  * @return int整型
  */
function atoi( str ) {
    // write code here
    if(!str) return 0;
    const max = Math.pow(2, 31) - 1;
    const min = -Math.pow(2, 31);
    if(str.length) {
        let res = parseInt(str);
        if(res > max) return max;
        if(res < min) return min;
        return res;
    }
}
module.exports = {
    atoi : atoi
};
```

## 数组中相加为0的三元组

**题目描述**

给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。

注意：

1. 三元组（a、b、c）中的元素必须按非降序排列。（即a≤b≤c）
2. 解集中不能包含重复的三元组。

```
例如，给定的数组 S = {-10 0 10 20 -10 -40},解集为(-10, 0, 10) (-10, -10, 20)
```

示例

输入

```
[-2,0,1,1,2]
```

返回值

```
[[-2,0,2],[-2,1,1]]
```

### 双指针

先排序，然后以第一个值为基准开始遍历，用双指针求第二个值和第三个值。

```js
/**
 * 
 * @param num int整型一维数组 
 * @return int整型二维数组
 */
function threeSum( num ) {
    // write code here
    let res = [];
    let len = num.length;
    num.sort((a, b) => a - b);
    for(let i = 0; i < len - 2; i++) {
        let head = i +1;
        let tail = len - 1;
        while(head < tail) {
            let sum = num[i] + num[head] + num[tail];
            if(sum > 0) {
                tail--;
            }else if(sum < 0) {
                head++;
            }else{
                res.push([num[i], num[head], num[tail]]);
                while(head + 1 < tail && num[head + 1] === num[head]) head++;// 防止重复
                while(tail - 1 < head && num[tail - 1] === num[head]) tail--;// 防止重复
                head++;
                tail--;
            }
        }
        while(i < len - 2 && num[i + 1] === num[i]) i++;// 防止重复
    }
    return res;
}
module.exports = {
    threeSum : threeSum
};
```

## 数组中未出现的最小正整数

**题目描述**

给定一个无序数组arr，找到数组中未出现的最小正整数

例如arr = [-1, 2, 3, 4]。返回1

arr = [1, 2, 3, 4]。返回5

[要求]

时间复杂度为O(n)，空间复杂度为*O*(1)

示例1

输入

```
[-1,2,3,4]
```

返回值

```
1
```

备注:

```
1 ≤N≤106
|arr_i|≤109
```

### 暴力

```js
/**
 * return the min number
 * @param arr int整型一维数组 the array
 * @return int整型
 */
function minNumberdisappered( arr ) {
    // write code here
    let num = 0;
    for (const a of arr) {
        if (a > 0) num ^= a; // 0 ^ 1 ^ 1 ^ 2 ^ 2 = 0, 0 ^ 1 ^ 2 ^ 2 = 1
    }
    for (let i = 1; i <= arr.length; ++i) {
        num ^= i;// 如果某个数不存在， num将不为0
    }
    return num == 0 ? arr.length + 1 : num;
}
module.exports = {
    minNumberdisappered : minNumberdisappered
};
```

```js
/**
 * return the min number
 * @param arr int整型一维数组 the array
 * @return int整型
 */
function minNumberdisappered( arr ) {
    // write code here
    const len = arr.length;
    for (let i = 1; i <= len; i++) {
        if (arr.indexOf(i) === -1) {
            return i;
        }
    }
    return len + 1;
}
module.exports = {
    minNumberdisappered : minNumberdisappered
};
```

# 百度

## 最大正方形

**题目描述**

给定一个由0和1组成的2维矩阵，返回该矩阵中最大的由1组成的正方形的面积

示例1

输入

```
[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]
```

返回值

```
4
```

### 动态规划

```js
/**
 * 最大正方形
 * @param matrix char字符型二维数组 
 * @return int整型
 */
function solve( matrix ) {
    // write code here
    let maxSquare = 0;
    let xLen = matrix.length;
    let yLen = matrix[0].length;
    for(let i = 0; i < xLen; i++) {
        for(let j = 0; j < yLen; j++) {
            if(matrix[i][j] == 1 && i != 0 && j != 0) {
                matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1;
            }
            maxSquare = Math.max(maxSquare, matrix[i][j]);
        }
    }
    return maxSquare * maxSquare;
}
module.exports = {
    solve : solve
};
```

## 反转链表

**题目描述**

输入一个链表，反转链表后，输出新链表的表头。

示例1

输入

```
{1,2,3}
```

返回值

```
{3,2,1}
```

初始化：3个指针
1）pre指针指向已经反转好的链表的最后一个节点，最开始没有反转，所以指向null
2）cur指针指向待反转链表的第一个节点，最开始第一个节点待反转，所以指向phead
3）res指针指向待反转链表的第二个节点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存
接下来，循环执行以下三个操作
1）res= cur, 保存作用
2）pre = res， res= cur; 指针后移，操作下一个未反转链表的第一个节点
3）res->next  = pre未反转链表的第一个节点的下个指针指向已反转链表的最后一个节点
循环条件，是cur != null
循环结束后，cur为null，所以返回pre，即为反转后的头结点

```js
/*function ListNode(x){
    this.val = x;
    this.next = null;
}*/
function ReverseList(pHead)
{
    // write code here
    let pre = null;
    let cur = pHead;
    let res = null;
    while (cur != null) {
        res = cur;
        cur = cur.next;
        res.next = pre;
        pre = res;
    }
    return res;
}
module.exports = {
    ReverseList : ReverseList
};
```

时间复杂度：O(n), 遍历一次链表
空间复杂度：O(1)

# 贝壳找房

## 牛牛们上班

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 256M，其他语言512M

在工厂中，有![img](https://www.nowcoder.com/equation?tex=%5Cmathit%20N&preview=true)个牛牛工作在一个流水线上，流水线可以看作一个坐标轴，第![img](https://www.nowcoder.com/equation?tex=%5Cmathit%20i&preview=true)个牛牛的位置是![img](https://www.nowcoder.com/equation?tex=X_i&preview=true)，延长其手臂的长度为![img](https://www.nowcoder.com/equation?tex=L_i&preview=true)，手臂可以朝向正向和反向，即第![img](https://www.nowcoder.com/equation?tex=%5Cmathit%20i&preview=true)个牛牛在流水线的工作范围为![img](https://www.nowcoder.com/equation?tex=%5BX_i%20-%20L_i%2CX_i%20%2B%20L_i%5D&preview=true)，你需要计算最多可以让多少个牛牛同时在流水线上工作且工作范围互不相交（只交在一个点也算相交）。

**输入描述:**

```
第一行一个整数 n
接下来 n 行，每行两个整数，Xi 和 Li
所有的输入为整数，且i≠j时，Xi ≠Xj
```

**输出描述:**

```
一行一个整数代表答案
```

**输入例子1:**

```
5
2 3
7 1
5 1
8 3
0 2
```

**输出例子1:**

```
2
```

**输入例子2:**

```
4
2 4
4 3
9 3
100 5
```

**输出例子2:**

```
2
```

**输入例子3:**

```
5
3 1
8 1
7 3
0 3
4 2
```

**输出例子3:**

```
2
```

### 动态规划

自测用例通过

case通过率为0.00%

```js
let len = readline();
// 构建输入数据input和dp数组
let input = [], dp = [];
for(let i = 0; i < len; i++) {
    input[i] = new Array(2).fill(0);
    dp[i] = new Array(2).fill(0);
}
// dp[index][0] 表示第index个没加上的总个数
// dp[index][1] 表示第index个加上的总个数
dp[0][0] = 0;
dp[0][1] = 1;

let index =0;
while(line = readline()) {
    let now = line.split(" ");
    input[index][0] = +now[0];
    input[index][1] = +now[1];
    index++;
}
input.sort((a, b) => a[0] - b[0]);

//分两种情况，和前一个有重合和前一个没有重合
for(let i = 1; i < len; ++i){
    for(let j = i - 1; j > -1; --j) {
        if((input[i][0] - input[i][1] - (input[j][0] + input[j][1])) > 0){
            dp[i][1] = Math.max(dp[j][1], dp[j][0]) + 1;
            dp[i][0] = Math.max(dp[j][0], dp[j][1]);
            continue;
        }else{
            dp[i][1] = dp[j][0] + 1;
            dp[i][0] = dp[j][0];
        }
    }
}
print(Math.max(dp[len - 1][0], dp[len - 1][1]));
```

# 跟谁学

## 求js数组的最大值和最小值的差值

```js
定义数组
var ary = [54,65,43,21,12,34,45,58,97,24];

1、字符串拼接法
利用toString和join把数组转换为字符串，再和Math的max和min方法分别进行拼接，最后执行eval方法
//eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。
/*
eval() 是一个危险的函数， 它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击。相似的 Function 就不容易被攻击。
eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。
*/
var maxN = eval("Math.max(" + ary.toString() + ")");
var minN = eval("Math.min(" + ary.toString() + ")");
或者
var maxN = eval("Math.max(" + ary.join() + ")");
var minN = eval("Math.min(" + ary.join() + ")");

2、排序法
先把数组从小到大排序，数组第一个即为最小值，最后一个即为最大值
ary.sort(function(a,b){return a-b;});
var minN = ary[0];
var maxN = ary[ary.length-1];

3、假设法
假设数组第一个为最大（或最小值），和后边进行比较，若后边的值比最大值大（或比最小值小），则替换最大值（或最小值）
var maxN = ary[0];
var minN = ary[0];
for(var i=1;i<ary.length;i++){
var cur = ary[i];
cur>maxN ? maxN=cur : null;
cur<minN ? minN=cur : null;
}

4、Math的max和min方法
使用apply方法使数组可以作为传递的参数或者...解构赋值

var maxN = Math.max.apply(null,ary);
var minN = Math.min.apply(null,ary);

var maxN = Math.max(...ary);
var minN = Math.min(...ary);
测试
console.log(maxN)
console.log(minN)
console.log(maxN - minN)
```

##  数组中出现次数超过一半的数字

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

### 排序

如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 n/2的元素（下标从 0 开始）一定是众数

```js
var majorityElement = function(nums) {
    nums.sort((a, b) => a - b);
    return nums[Math.floor(nums.length / 2)];
}
```

- 时间复杂度：O(nlogn)。将数组排序的时间复杂度为O(nlogn)。
- 空间复杂度：O(logn)。如果使用语言自带的排序算法，需要使用 O(logn) 的栈空间。如果自己编写堆排序，则只需要使用 O(1)的额外空间。

### 投票算法

投票算法的原理是通过不断消除不同元素直到没有不同元素，剩下的元素就是我们要找的元素。

- 我们维护一个候选众数 majority和它出现的次数 count。初始时 majority可以为nums[0]，count 为 1；

- 我们遍历数组 nums 中的所有元素，对于每个元素 i，在判断 i之前，如果 count 的值为 0，我们先将 i的值赋予 majority，随后我们判断 i：

  - 如果 i与 majority相等，那么计数器 count 的值增加 1；
  - 如果 i与 majority不等，那么计数器 count 的值减少 1。

  在遍历完成后，majority即为整个数组的众数。

```js
var majorityElement = function(nums) {
    let count = 1;
    let majority = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (count === 0) {
            majority = nums[i];
        }
        if (nums[i] === majority) {
            count++;
        }else {
            count--;
        }
    }
    return majority;
}
```

- 时间复杂度：O(N)，其中N为数组长度
- 空间复杂度：O(1)

# 牛客



# 解题模板

- node.js

```js
var readline = require('readline');

rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});
//单行输入
rl.on('line', function(data) {
    // 获取输入
    var inputs = data.trim().split(' ');

    // 处理
    var result = deal(inputs);

    // 输出结果
    console.log(result);
});


function deal(inputs) {
    var result = '';

    // dosomething

    return result;
}
```

## 例题

输入N个（N<=10000）数字，求出这N个数字中的最大值和最小值。每个数字的绝对值不大于1000000。

```js
var readline = require('readline');
var rl = readline.createInterface({
    input:process.stdin,
    output:process.stdout,
});
var num = 0;
 
rl.on('line',function(input){
    if(num==0){
        num = input.trim();
    }
    else{
        var iptArr = input.split(' ');
        if(iptArr.length==num){
            var maxNum = Math.max.apply(null,iptArr);
            var minNum = Math.min.apply(null,iptArr);
            var result = maxNum + ' ' + minNum;
            console.log(result);
            return result;
        }
    }
})
//输入
5                    //输入N个数的数量
12 18 5 20 10        //N个数
20 5                //返回结果
```

 